# PROMPT_20260216_glm47_w2

Du bist `glm 4.7` als QA/Gate-Cell auf Branch `feature/v1-ux-aiB`.

## Kontext (zuerst lesen)
- `handoffs/HANDOFF_20260216_glm47_w1.md`
- `handoffs/HANDOFF_20260216_core_to_ai3_w6.md`
- `handoffs/HANDOFF_20260216_core_to_gemini_w8.md`
- `handoffs/HANDOFF_20260216_ai3_w4.md`
- `roadmap_ctp/ERROR_CODE_MAPPING_QA_20260215.md`

## Harte Regeln
1. Keine Edits in:
- `modeling/**`
- `gui/main_window.py`
- `gui/viewport_pyvista.py`
- `gui/widgets/status_bar.py`

2. Fokusbereiche:
- `scripts/**`
- `roadmap_ctp/**`
- QA-nahe `test/**`
- optional `.github/workflows/**`
- optional `handoffs/**`

3. Keine Aussagen ohne Repro-Command + Resultat.
4. Keine Platzhalter-Doku. Alles evidenzbasiert.

## Zielbild W2
Aus W1 wird eine release-taugliche QA-Schicht mit:
- rebaselined Zahlen (aktuellster Stand, inkl. neuer Drift-Cases)
- reproduzierbaren Gate-Artefakten (md + json)
- klarer BLOCKED-vs-FAIL-Semantik
- belastbarer Hygiene-Policy (Warn/Fail eindeutig)

## Aufgaben (umfangreich, Reihenfolge bindend)

### WP1 (P0): Rebaseline auf aktuellen Core-Stand + Drift-Taxonomie
Aktualisiere und konsolidiere:
- `roadmap_ctp/GATE_DEFINITIONS_20260215.md`
- `roadmap_ctp/REGRESSION_PACK_STATUS_20260215.md`
- `roadmap_ctp/FLAKY_BURN_DOWN_20260215.md`
- `roadmap_ctp/ERROR_CODE_MAPPING_QA_20260215.md`

Pflichten:
1. Zahlen auf den realen aktuellen Stand ziehen (nicht W4/W5 stehen lassen).
2. Drift-Coverage explizit ausweisen:
- edge single_ref_pair geometric conflict -> drift
- face single_ref_pair geometric conflict -> drift
- sweep path single_ref_pair geometric conflict -> drift
3. Mapping-Matrix mit `reference_kind`-Dimension ergänzen (`edge|face|...`).
4. Eine kompakte "What changed since W1" Sektion einführen.

---

### WP2 (P0): Gate-Evidence automatisieren (nicht nur manuell)
Erzeuge ein kleines, robustes Evidence-Tooling:
- `scripts/generate_gate_evidence.ps1` (neu)

Input:
- optional `-StrictHygiene`
- optional `-OutPrefix` (default `roadmap_ctp/QA_EVIDENCE_W2_YYYYMMDD`)

Output:
- `<prefix>.md`
- `<prefix>.json`

Pflichten:
1. Script ruft nacheinander auf:
- Core-Gate Command(s)
- UI-Gate Command(s)
- Hygiene-Check
2. Bei Fehlern weiter sammeln (best effort), am Ende konsolidierte Summary.
3. JSON enthält mindestens:
- timestamp, branch, python version
- command, exit_code, duration, status
- pass/fail/skip/error counts (wo parsebar)
4. MD enthält:
- Executive summary
- Tabelle je Gate
- Blocker-Liste mit Infra/Logic Klassifizierung

---

### WP3 (P0): Gate-Contract Tests für Runner (Smoke-Level)
Lege QA-Tests für Runner-Verhalten an:
- `test/test_gate_runner_contract.py` (neu)

Scope:
1. Prüft, dass Scripts existieren und aufrufbar sind.
2. Prüft, dass Output-Schlüssel vorhanden sind (Status/Exit/Duration).
3. Prüft BLOCKED-vs-FAIL Klassifizierung mindestens via fixture/sample-output.

Hinweis:
- Kein Endlos-Testen gegen komplette Suiten in Unit-Tests.
- Verwende kleine, stabile Contract-Checks.

---

### WP4 (P1): CI-Gate Workflow auf belastbaren Stand bringen
Arbeite an:
- `.github/workflows/gates.yml`

Pflichten:
1. Jobs:
- `core-gate`
- `ui-gate`
- `hygiene-gate`
- optional `evidence-artifact`
2. Für `ui-gate` explizite BLOCKED-Handhabung dokumentieren.
3. Artifacts hochladen:
- Gate-Logs
- Evidence JSON/MD
4. Readability:
- klare Job-Summary (`GITHUB_STEP_SUMMARY`)

---

### WP5 (P1): Workspace-Hygiene operationalisieren
Aktualisiere:
- `roadmap_ctp/WORKSPACE_HYGIENE_GATE_20260215.md`

Pflichten:
1. Trenne klar:
- temporary outputs
- debug helpers
- legitime neue assets
2. Für jede Violation:
- owner
- entscheidung (`keep|move|delete|ignore`) + datum
3. Ergänze "Hygiene SLA" (z. B. <= N offene Violations auf Release-Branch).

---

### WP6 (P2, optional aber gewünscht): Flaky-Strategie harden
Erstelle:
- `roadmap_ctp/FLAKY_STRATEGY_W2_20260216.md` (neu)

Inhalt:
1. Klassifizierung: deterministic fail / infra blocked / flaky suspect
2. Re-run policy (z. B. max retries, wann quarantäne)
3. Gate policy (wann FAIL, wann BLOCKED)
4. Roadmap für automatisierte Flaky-Erkennung

## Pflicht-Validierung (vollständig ausführen)
```powershell
conda run -n cad_env python -m pytest -q test/test_parametric_reference_modelset.py
conda run -n cad_env python -m pytest -q test/test_feature_error_status.py test/test_tnp_v4_feature_refs.py test/test_trust_gate_core_workflow.py test/test_cad_workflow_trust.py test/test_brepopengun_offset_api.py test/test_feature_flags.py test/test_tnp_stability.py test/test_feature_edit_robustness.py test/test_project_roundtrip_persistence.py test/test_parametric_reference_modelset.py
conda run -n cad_env python -m pytest -q test/test_ui_abort_logic.py test/harness/test_interaction_consistency.py
conda run -n cad_env python -m pytest -q test/test_gate_runner_contract.py
powershell -ExecutionPolicy Bypass -File scripts/gate_core.ps1
powershell -ExecutionPolicy Bypass -File scripts/gate_ui.ps1
powershell -ExecutionPolicy Bypass -File scripts/gate_all.ps1
powershell -ExecutionPolicy Bypass -File scripts/gate_all.ps1 -StrictHygiene
powershell -ExecutionPolicy Bypass -File scripts/hygiene_check.ps1
powershell -ExecutionPolicy Bypass -File scripts/hygiene_check.ps1 -FailOnUntracked
powershell -ExecutionPolicy Bypass -File scripts/generate_gate_evidence.ps1
powershell -ExecutionPolicy Bypass -File scripts/generate_gate_evidence.ps1 -StrictHygiene
```

## Rückgabeformat
Datei:
- `handoffs/HANDOFF_20260216_glm47_w2.md`

Struktur:
1. Problem
2. API/Behavior Contract
3. Impact
4. Validation
5. Breaking Changes / Rest-Risiken

Zusatzpflicht:
- Liste aller geänderten Dateien + Zweck (1 Satz)
- Nächste 5 priorisierte Folgeaufgaben mit Owner + ETA
- Kurze Delta-Sektion gegen W1 (was wurde konkret verbessert)
