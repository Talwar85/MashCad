"""
Body - 3D-Körper (Body) mit RobustPartBuilder Logik

Phase 2 TNP: Integrierter TNP-Tracker für robuste Shape-Referenzierung.
"""

from dataclasses import asdict, dataclass, field
import tempfile
from typing import List, Optional, Tuple, Union, Any
from enum import Enum, auto
import math
import uuid
import sys
import os
import traceback
from loguru import logger

# Import HAS_OCP and HAS_BUILD123D flags
HAS_BUILD123D = False
HAS_OCP = False

try:
    from OCP.BRepPrimAPI import BRepPrimAPI_MakeBox, BRepPrimAPI_MakeCylinder, BRepPrimAPI_MakePrism
    from OCP.BRepBuilderAPI import (
        BRepBuilderAPI_MakeEdge, BRepBuilderAPI_MakeWire, BRepBuilderAPI_MakeFace,
        BRepBuilderAPI_MakeSolid, BRepBuilderAPI_Sewing
    )
    from OCP.BRepAlgoAPI import BRepAlgoAPI_Fuse, BRepAlgoAPI_Cut, BRepAlgoAPI_Common
    from OCP.BRepOffsetAPI import BRepOffsetAPI_MakePipe
    from OCP.BRepFilletAPI import BRepFilletAPI_MakeFillet, BRepFilletAPI_MakeChamfer
    from OCP.StlAPI import StlAPI_Writer
    from OCP.BRepMesh import BRepMesh_IncrementalMesh
    from OCP.TopoDS import TopoDS_Shape, TopoDS_Solid, TopoDS_Face, TopoDS_Edge, TopoDS_Wire
    from OCP.TopExp import TopExp_Explorer
    from OCP.TopAbs import TopAbs_FACE, TopAbs_EDGE, TopAbs_SOLID
    from OCP.gp import gp_Pnt, gp_Vec, gp_Dir, gp_Ax1, gp_Ax2, gp_Pln, gp_Trsf
    from OCP.BRepBuilderAPI import BRepBuilderAPI_Transform
    from OCP.ShapeFix import ShapeFix_Shape, ShapeFix_Solid
    from OCP.BRepCheck import BRepCheck_Analyzer
    HAS_OCP = True
except ImportError as e:
    logger.warning(f"! OCP nicht gefunden: {e}")

try:
    from build123d import (
        Box, Cylinder, Sphere, Solid, Shape,
        extrude, revolve, fillet, chamfer,
        loft, sweep, offset,
        Axis, Plane, Locations, Vector,
        BoundBox,
        BuildPart, BuildSketch, BuildLine,
        Part, Sketch as B123Sketch,
        Rectangle as B123Rect, Circle as B123Circle,
        Polyline, Polygon, make_face, Mode,
        export_stl, export_step,
        GeomType
    )
    HAS_BUILD123D = True
    if not hasattr(BoundBox, "bounding_box"):
        @staticmethod
        def _compat_bounding_box(shape):
            return shape.bounding_box() if hasattr(shape, "bounding_box") else BoundBox(shape)
        BoundBox.bounding_box = _compat_bounding_box
    def _compat_geomtype_call(self):
        return self
    GeomType.__call__ = _compat_geomtype_call
except ImportError as e:
    logger.warning(f"! build123d nicht gefunden: {e}")

# Core imports
import modeling.brep_cache as brep_cache
from modeling.cad_tessellator import CADTessellator
from config.tolerances import Tolerances
from config.feature_flags import is_enabled
from meshconverter.direct_mesh_converter import DirectMeshConverter
from meshconverter.brep_optimizer import BRepOptimizer
from modeling.mesh_converter import MeshToBREPConverter
from modeling.result_types import OperationResult, BooleanResult, ResultStatus
from modeling.geometry_validator import GeometryValidator, ValidationResult, ValidationLevel
from modeling.geometry_healer import GeometryHealer, HealingResult, HealingStrategy
from modeling.nurbs import NURBSCurve, NURBSSurface, ContinuityMode, CurveType
from modeling.step_io import STEPWriter, STEPReader, STEPSchema, export_step as step_export
from modeling.feature_dependency import FeatureDependencyGraph, get_dependency_graph
from modeling.boolean_engine_v4 import BooleanEngineV4

# TNP v4.0
from modeling.tnp_system import (
    ShapeNamingService, ShapeID, ShapeType,
    OperationRecord
)

# OCP-First Migration
from modeling.ocp_helpers import (
    OCPExtrudeHelper,
    OCPFilletHelper,
    OCPChamferHelper
)

# Body Serialization (extracted module)
from modeling.body_serialization import (
    body_to_dict,
    body_from_dict,
    _normalize_status_details_for_load,
)

# Body Mixins (extracted modules)
from modeling.body_rebuild import BodyRebuildMixin
from modeling.body_resolve import BodyResolveMixin
from modeling.body_extrude import BodyExtrudeMixin
from modeling.body_compute_mixin import BodyComputeMixin

# AR-002/AR-003 extracted modules
from modeling.geometry_utils import (
    solid_metrics,
    canonicalize_indices,
    get_face_center,
    get_face_area,
    validate_plane_normal,
    format_index_refs_for_error,
    format_shape_refs_for_error,
    collect_feature_reference_diagnostics,
    collect_feature_reference_payload,
    _solid_metrics,
    _canonicalize_indices,
    _get_face_center,
    _get_face_area,
    _format_index_refs_for_error,
    _format_shape_refs_for_error,
    _collect_feature_reference_diagnostics,
    _collect_feature_reference_payload,
)

from modeling.shape_builders import (
    convert_legacy_nsided_edge_selectors,
    convert_legacy_edge_selectors,
    convert_line_profiles_to_polygons,
    filter_profiles_by_selector,
    get_plane_from_sketch,
    lookup_geometry_for_polygon,
    make_wire_from_mixed_geometry,
    _convert_legacy_nsided_edge_selectors,
    _convert_legacy_edge_selectors,
    _convert_line_profiles_to_polygons,
    _filter_profiles_by_selector,
    _get_plane_from_sketch,
    _lookup_geometry_for_polygon,
    _make_wire_from_mixed_geometry,
)

from modeling.feature_operations import (
    record_tnp_failure,
    consume_tnp_failure,
    classify_error_code,
    default_next_action_for_code,
    build_operation_error_details,
    normalize_status_details_for_load,
    safe_operation,
    _record_tnp_failure,
    _consume_tnp_failure,
    _classify_error_code,
    _default_next_action_for_code,
    _build_operation_error_details,
    _normalize_status_details_for_load,
    _safe_operation,
)

from modeling.body_state import (
    serialize_shape_id,
    deserialize_shape_id,
    serialize_shape_ids,
    deserialize_shape_ids,
    serialize_feature,
    serialize_feature_base,
    compare_body_states,
    body_state_summary,
    serialize_brep,
    deserialize_brep,
    _serialize_shape_id,
    _deserialize_shape_id,
    _serialize_shape_ids,
    _deserialize_shape_ids,
    _serialize_feature,
    _serialize_feature_base,
    _compare_body_states,
    _body_state_summary,
    _serialize_brep,
    _deserialize_brep,
)

# Feature imports
from modeling.features.base import Feature, FeatureType
from modeling.features.extrude import ExtrudeFeature, PushPullFeature
from modeling.features.revolve import RevolveFeature
from modeling.features.fillet_chamfer import FilletFeature, ChamferFeature
from modeling.features.pattern import PatternFeature
from modeling.features.boolean import BooleanFeature
from modeling.features.transform import TransformFeature
from modeling.features.advanced import (
    LoftFeature, SweepFeature, ShellFeature, HoleFeature,
    DraftFeature, SplitFeature, ThreadFeature, HollowFeature,
    NSidedPatchFeature, SurfaceTextureFeature, PrimitiveFeature,
    LatticeFeature
)
from modeling.features.import_feature import ImportFeature
from modeling.construction import ConstructionPlane

# Sketch import
from sketcher import Sketch


class Body(BodyRebuildMixin, BodyResolveMixin, BodyExtrudeMixin, BodyComputeMixin):
    """
    3D-KÃ¶rper (Body) mit RobustPartBuilder Logik.

    Phase 2 TNP: Integrierter TNP-Tracker fÃ¼r robuste Shape-Referenzierung.
    
    Note: Methods are organized in mixins:
    - BodyRebuildMixin: _rebuild() and related methods
    - BodyResolveMixin: _resolve_* methods for TNP
    - BodyExtrudeMixin: _extrude_* and _compute_extrude_* methods
    - BodyComputeMixin: _compute_* methods for features
    """

    def __init__(self, name: str = "Body", document=None):
        self.name = name
        self.id = str(uuid.uuid4())[:8]
        self.features: List[Feature] = []
        self.rollback_index: Optional[int] = None  # None = all features active
        
        # Referenz zum Document (fÃ¼r TNP v4.0 Naming Service)
        self._document = document

        # === Multi-Body Split-Tracking (AGENTS.md Phase 2) ===
        # Wenn dieser Body via Split entstanden ist:
        self.source_body_id: Optional[str] = None  # ID des Original-Bodies vor Split
        self.split_index: Optional[int] = None      # Index des Split-Features in der Historie
        self.split_side: Optional[str] = None       # "above" oder "below"

        # CAD Kernel Objekte
        self._build123d_solid = None
        self.shape = None

        # === TNP v4.0: Shape Naming Service (im Document) ===
        # Nicht mehr hier - Service ist jetzt im Document zentralisiert
        
        # NOTE: Altes TNP-System (Phase 8.2/3) deaktiviert - v4.0 aktiv

        # === PHASE 7: Feature Dependency Graph ===
        self._dependency_graph = FeatureDependencyGraph()
        self._solid_checkpoints: dict = {}  # {feature_index: solid} - In-Memory Checkpoints
        
        # === TNP v3.0: Solid Generation Tracking ===
        # Wird inkrementiert wenn sich Solid durch Boolean Ã¤ndert
        # Features merken sich auf welcher Generation sie basieren
        self._solid_generation = 0
        self._last_boolean_feature_index = -1  # Index des letzten Boolean-Features

        # === PHASE 2: Single Source of Truth ===
        # PyVista/VTK Objekte - LAZY LOADED aus _build123d_solid
        self._mesh_cache = None       # pv.PolyData (Faces) - privat!
        self._edges_cache = None      # pv.PolyData (Edges) - privat!
        self._face_info_cache = {}    # {face_id: {"normal": (x,y,z), "center": (x,y,z)}} - B-Rep Info!
        self._mesh_cache_valid = False  # Invalidiert wenn Solid sich Ã¤ndert

        # Kosmetische Gewinde-Linien (Helix-Visualisierung ohne echte Geometrie)
        self._cosmetic_lines_cache = None   # pv.PolyData (Helix-Linien)
        self._cosmetic_lines_valid = False

        # Legacy Visualisierungs-Daten (Nur als Fallback)
        self._mesh_vertices: List[Tuple[float, float, float]] = []
        self._mesh_triangles: List[Tuple[int, int, int]] = []
        self._mesh_normals = []
        self._mesh_edges = []
        self._last_operation_error = ""
        self._last_operation_error_details = {}
        self._pending_tnp_failure = None

    def _get_face_center(self, face):
        """Helper for TNP registration - delegates to geometry_utils."""
        return get_face_center(face)

    def _get_face_area(self, face):
        """Helper for TNP registration - delegates to geometry_utils."""
        return get_face_area(face)

    # NOTE: Static methods below delegate to shape_builders module for maintainability
    # These are kept as static methods for backward compatibility with existing code
    
    @staticmethod
    def _convert_legacy_nsided_edge_selectors(edge_selectors: Optional[List]) -> List[dict]:
        """Delegates to shape_builders module - see convert_legacy_nsided_edge_selectors."""
        return convert_legacy_nsided_edge_selectors(edge_selectors)

    @staticmethod
    def _convert_legacy_edge_selectors(edge_selectors: Optional[List]) -> List[dict]:
        """Delegates to shape_builders module - see convert_legacy_edge_selectors."""
        return convert_legacy_edge_selectors(edge_selectors)

    # === PHASE 2: Lazy-Loaded Properties ===
    @property
    def vtk_mesh(self):
        """Lazy-loaded mesh from solid (Single Source of Truth)"""
        if not self._mesh_cache_valid or self._mesh_cache is None:
            self._regenerate_mesh()
        return self._mesh_cache

    @vtk_mesh.setter
    def vtk_mesh(self, value):
        """Setter fÃ¼r importierte Meshes (vor BREP-Konvertierung)"""
        self._mesh_cache = value
        self._mesh_cache_valid = True

    @property
    def vtk_edges(self):
        """Lazy-loaded edges from solid (Single Source of Truth)"""
        if not self._mesh_cache_valid or self._edges_cache is None:
            self._regenerate_mesh()
        return self._edges_cache

    @property
    def face_info(self):
        """B-Rep Face Info: {face_id: {"normal": (x,y,z), "center": (x,y,z)}}"""
        if not self._mesh_cache_valid:
            self._regenerate_mesh()
        return self._face_info_cache

    def get_brep_normal(self, face_id: int):
        """Gibt die B-Rep Normale fÃ¼r eine Face-ID zurÃ¼ck (oder None)."""
        info = self.face_info.get(face_id)
        if info:
            return info.get("normal")
        return None

    def _regenerate_mesh(self):
        """Single point of mesh generation - called automatically when needed"""
        if self._build123d_solid is None:
            self._mesh_cache = None
            self._edges_cache = None
            self._mesh_cache_valid = True
            return

        # Generate from solid via CADTessellator WITH FACE IDs!
        # Dies ermÃ¶glicht exakte Face-Selektion (statt Heuristik nach Normalen)
        self._mesh_cache, self._edges_cache, self._face_info_cache = CADTessellator.tessellate_with_face_ids(
            self._build123d_solid
        )
        self._mesh_cache_valid = True
        n_pts = self._mesh_cache.n_points if self._mesh_cache else 0
        n_edges = self._edges_cache.n_lines if self._edges_cache else 0
        n_faces = len(self._face_info_cache) if self._face_info_cache else 0
        logger.debug(f"Mesh regenerated for '{self.name}': {n_pts} pts, {n_edges} edges, {n_faces} B-Rep faces")

    @property
    def vtk_cosmetic_lines(self):
        """Lazy-loaded kosmetische Gewinde-Linien (Helix-Visualisierung)."""
        if not self._cosmetic_lines_valid:
            self._regenerate_cosmetic_lines()
        return self._cosmetic_lines_cache

    def _regenerate_cosmetic_lines(self):
        """Erzeugt Helix-Linien fÃ¼r alle kosmetischen ThreadFeatures."""
        self._cosmetic_lines_valid = True
        cosmetic_threads = [f for f in self.features
                            if isinstance(f, ThreadFeature) and f.cosmetic]
        if not cosmetic_threads:
            self._cosmetic_lines_cache = None
            return

        try:
            import numpy as np
            import pyvista as pv
            from build123d import Helix

            all_points = []
            all_lines = []
            offset = 0

            for feat in cosmetic_threads:
                r = feat.diameter / 2.0
                H = 0.8660254 * feat.pitch
                groove_depth = 0.625 * H

                # Zwei Helix-Linien: Innen- und AuÃŸenradius des Gewindes
                for radius in [r - groove_depth, r]:
                    helix = Helix(
                        pitch=feat.pitch,
                        height=feat.depth,
                        radius=radius,
                        center=tuple(feat.position),
                        direction=tuple(feat.direction)
                    )
                    # Sample Punkte entlang der Helix
                    n_samples = max(20, int(feat.depth / feat.pitch * 12))
                    pts = []
                    for j in range(n_samples + 1):
                        t = j / n_samples
                        pt = helix.position_at(t)
                        pts.append([pt.X, pt.Y, pt.Z])

                    pts_arr = np.array(pts)
                    n_pts = len(pts_arr)
                    all_points.append(pts_arr)

                    # Polyline: [n_pts, idx0, idx1, ..., idx_n-1]
                    line = [n_pts] + list(range(offset, offset + n_pts))
                    all_lines.extend(line)
                    offset += n_pts

            if all_points:
                points = np.vstack(all_points)
                self._cosmetic_lines_cache = pv.PolyData(points, lines=all_lines)
                logger.debug(f"[COSMETIC] {len(cosmetic_threads)} thread(s) â†’ "
                             f"{points.shape[0]} pts helix lines")
            else:
                self._cosmetic_lines_cache = None
        except Exception as e:
            logger.warning(f"Cosmetic thread lines failed: {e}")
            self._cosmetic_lines_cache = None

    def _get_solid_with_threads(self):
        """Berechnet echte Gewinde auf einer Kopie des Solids (fÃ¼r Export).

        Iteriert Ã¼ber alle kosmetischen ThreadFeatures und wendet
        _compute_thread() auf eine Kopie an. Original bleibt unverÃ¤ndert.
        """
        if self._build123d_solid is None:
            return None

        cosmetic_threads = [f for f in self.features
                            if isinstance(f, ThreadFeature) and f.cosmetic]
        if not cosmetic_threads:
            return self._build123d_solid

        logger.info(f"[EXPORT] Computing {len(cosmetic_threads)} real thread(s) for export...")
        current = self._build123d_solid
        for feat in cosmetic_threads:
            try:
                current = self._compute_thread(feat, current)
                logger.debug(f"[EXPORT] Thread {feat.name} applied")
            except Exception as e:
                logger.warning(f"[EXPORT] Thread {feat.name} failed: {e}")

        return current

    def invalidate_mesh(self):
        """Invalidiert Mesh-Cache - nÃ¤chster Zugriff regeneriert automatisch"""
        self._mesh_cache_valid = False
        self._cosmetic_lines_valid = False

        # WICHTIG: Auch Face-Info-Cache lÃ¶schen!
        # Sonst bleiben alte Face-IDs bestehen die nach Boolean ungÃ¼ltig sind
        self._face_info_cache = {}

        # Phase 4.3: Auch Topology-Cache invalidieren
        if self._build123d_solid is not None:
            try:
                CADTessellator.invalidate_topology_cache(id(self._build123d_solid.wrapped))
            except Exception as e:
                logger.debug(f"[__init__.py] Fehler: {e}")
                pass  # Solid hat kein wrapped (selten)

    def request_async_tessellation(self, on_ready=None):
        """
        Phase 9: Startet Tessellation im Hintergrund (Non-Blocking).

        Das Mesh wird asynchron generiert und via Callback zurÃ¼ckgegeben.
        vtk_mesh Property bleibt synchron (fÃ¼r KompatibilitÃ¤t).

        Args:
            on_ready: Optional callback(body_id, mesh, edges, face_info)
                      Wenn None, wird das Mesh direkt in den Cache geschrieben.
        """
        if not is_enabled("async_tessellation"):
            # Synchroner Fallback
            self._regenerate_mesh()
            return

        if self._build123d_solid is None:
            return

        from gui.workers.tessellation_worker import TessellationWorker

        def _on_mesh_ready(body_id, mesh, edges, face_info):
            """Callback: Mesh ist fertig, in Body-Cache schreiben."""
            self._mesh_cache = mesh
            self._edges_cache = edges
            self._face_info_cache = face_info
            self._mesh_cache_valid = True
            n_pts = mesh.n_points if mesh else 0
            logger.debug(f"Async Mesh ready for '{self.name}': {n_pts} pts")
            if on_ready:
                on_ready(body_id, mesh, edges, face_info)

        worker = TessellationWorker(self.id, self._build123d_solid)
        worker.mesh_ready.connect(_on_mesh_ready)
        # Worker-Referenz halten damit er nicht garbage-collected wird
        self._tessellation_worker = worker
        worker.start()

    def add_feature(self, feature: Feature, rebuild: bool = True):
        """Feature hinzufÃ¼gen und optional Geometrie neu berechnen.

        Args:
            feature: Das Feature das hinzugefÃ¼gt werden soll
            rebuild: Wenn False, wird das Feature nur zur Liste hinzugefÃ¼gt
                     ohne _rebuild() aufzurufen. NÃ¼tzlich wenn das Solid
                     bereits durch eine direkte Operation (z.B. BRepFeat)
                     aktualisiert wurde.
        """
        self.features.append(feature)

        # Phase 7: Feature im Dependency Graph registrieren
        from config.feature_flags import is_enabled
        if is_enabled("feature_dependency_tracking"):
            self._dependency_graph.add_feature(feature.id, len(self.features) - 1)

        if rebuild:
            self._rebuild(changed_feature_id=feature.id)

    def remove_feature(self, feature: Feature):
        if feature in self.features:
            feature_index = self.features.index(feature)

            # Phase 7: Checkpoints nach diesem Feature invalidieren
            from config.feature_flags import is_enabled
            if is_enabled("feature_dependency_tracking"):
                self._dependency_graph.remove_feature(feature.id)
                # LÃ¶sche Checkpoints ab diesem Index
                for idx in list(self._solid_checkpoints.keys()):
                    if idx >= feature_index:
                        del self._solid_checkpoints[idx]

            self.features.remove(feature)
            self._rebuild()

    def update_feature(self, feature: Feature):
        """
        Phase 7: Aktualisiert ein Feature und triggert inkrementellen Rebuild.

        Nutzt den Dependency Graph um nur die betroffenen Features neu zu berechnen.

        Args:
            feature: Das geÃ¤nderte Feature (muss bereits in self.features sein)
        """
        if feature not in self.features:
            logger.error(f"Feature '{feature.id}' nicht in Body '{self.name}' gefunden")
            return

        from config.feature_flags import is_enabled

        if is_enabled("feature_dependency_tracking"):
            feature_index = self.features.index(feature)

            # Checkpoints ab diesem Feature invalidieren
            for idx in list(self._solid_checkpoints.keys()):
                if idx >= feature_index:
                    del self._solid_checkpoints[idx]

            # Inkrementeller Rebuild
            self._rebuild(changed_feature_id=feature.id)
        else:
            # Fallback: Voller Rebuild
            self._rebuild()
            
    def convert_to_brep(self, mode: str = "auto"):
        """
        Wandelt Mesh in CAD-Solid um.

        Verwendet DirectMeshConverter + BRepOptimizer fÃ¼r zuverlÃ¤ssige Konvertierung.
        Faces werden zu BREP konvertiert und dann mit UnifySameDomain optimiert.
        """
        if self._build123d_solid is not None:
            logger.info(f"Body '{self.name}' ist bereits BREP.")
            return True

        if self.vtk_mesh is None:
            logger.warning("Keine Mesh-Daten vorhanden.")
            return False

        logger.info(f"Starte Mesh-zu-BREP Konvertierung fÃ¼r '{self.name}'...")
        logger.info(f"  Mesh: {self.vtk_mesh.n_points} Punkte, {self.vtk_mesh.n_cells} Faces")

        try:
            # 1. DirectMeshConverter: Mesh -> BREP (1:1 Faces)
            from meshconverter.direct_mesh_converter import DirectMeshConverter
            from meshconverter.brep_optimizer import optimize_brep

            converter = DirectMeshConverter(unify_faces=False)
            result = converter.convert(self.vtk_mesh)

            if result.solid is None:
                logger.error(f"DirectMeshConverter fehlgeschlagen: {result.message}")
                return False

            logger.info(f"  BREP erstellt: {result.stats.get('faces_created', '?')} Faces")

            # 2. BRepOptimizer: Face-Reduktion + Primitiv-Erkennung
            optimized, opt_stats = optimize_brep(result.solid)

            faces_before = opt_stats.get('faces_before', 0)
            faces_after = opt_stats.get('faces_after', 0)
            reduction = faces_before - faces_after

            logger.info(f"  Optimiert: {faces_before} -> {faces_after} Faces ({reduction} reduziert)")
            if opt_stats.get('cylinders_detected', 0) > 0:
                logger.info(f"  Zylinder erkannt: {opt_stats['cylinders_detected']}")
            if opt_stats.get('spheres_detected', 0) > 0:
                logger.info(f"  Kugeln erkannt: {opt_stats['spheres_detected']}")

            # 3. In Build123d Solid wrappen
            from build123d import Solid
            solid = Solid(optimized)

            if solid and hasattr(solid, 'wrapped') and not solid.wrapped.IsNull():
                self._build123d_solid = solid
                self.shape = solid.wrapped

                # TNP v4.0: ShapeID-Registrierung fÃ¼r konvertierte Geometrie
                try:
                    if self._document and hasattr(self._document, '_shape_naming_service'):
                        service = self._document._shape_naming_service
                        if service is not None:
                            feature_id = f"mesh_convert_{self.id}"

                            # Alle Edges registrieren
                            edge_count = service.register_solid_edges(solid, feature_id)

                            # Alle Faces registrieren
                            try:
                                from OCP.TopTools import TopTools_IndexedMapOfShape
                                from OCP.TopExp import TopExp
                                from OCP.TopoDS import TopoDS
                                from modeling.tnp_system import ShapeType

                                face_map = TopTools_IndexedMapOfShape()
                                TopExp.MapShapes_s(solid.wrapped, TopAbs_FACE, face_map)

                                for fi in range(1, face_map.Extent() + 1):
                                    face_shape = TopoDS.Face_s(face_map.FindKey(fi))
                                    service.register_shape(
                                        ocp_shape=face_shape,
                                        shape_type=ShapeType.FACE,
                                        feature_id=feature_id,
                                        local_index=fi - 1
                                    )

                                logger.info(f"  [TNP] {edge_count} Edges, {face_map.Extent()} Faces registriert")
                            except Exception as e:
                                logger.debug(f"[TNP] Face-Registrierung fehlgeschlagen: {e}")
                except Exception as e:
                    logger.debug(f"[TNP] Registrierung fehlgeschlagen: {e}")

                # === NEU: ImportFeature erstellen fÃ¼r Rebuild-Support ===
                # BREP serialisieren (via BytesIO Stream)
                try:
                    from OCP.BRepTools import BRepTools
                    import io

                    # BRepTools.Write_s braucht einen BytesIO Stream
                    stream = io.BytesIO()
                    BRepTools.Write_s(solid.wrapped, stream)
                    brep_string = stream.getvalue().decode('utf-8')

                    if brep_string:
                        # ImportFeature erstellen
                        import_feature = ImportFeature(
                            name=f"Import ({self.name})",
                            brep_string=brep_string,
                            source_file=getattr(self, 'source_file', self.name),
                            source_type="mesh_convert"
                        )

                        # Alte Features lÃ¶schen und ImportFeature als Basis setzen
                        self.features.clear()
                        self.features.append(import_feature)

                        logger.info(f"  ImportFeature erstellt ({len(brep_string)} bytes BREP)")
                except Exception as e:
                    logger.warning(f"ImportFeature Erstellung fehlgeschlagen: {e}")
                    # Konvertierung war trotzdem erfolgreich, nur ohne Rebuild-Support

                logger.success(f"Body '{self.name}' erfolgreich konvertiert!")

                # Mesh neu berechnen (vom BREP abgeleitet fÃ¼r Konsistenz)
                self._update_mesh_from_solid(solid)
                return True
            else:
                logger.warning("Konvertierung lieferte kein gÃ¼ltiges Solid.")
                return False

        except Exception as e:
            logger.error(f"Konvertierung fehlgeschlagen: {e}")
            traceback.print_exc()
            return False
            
    # NOTE: These static methods delegate to geometry_utils module for maintainability
    # They are kept here for backward compatibility with existing code
    
    @staticmethod
    def _format_index_refs_for_error(label: str, refs, max_items: int = 3) -> str:
        """Delegates to geometry_utils module."""
        return format_index_refs_for_error(label, refs, max_items)

    @staticmethod
    def _format_shape_refs_for_error(label: str, refs, max_items: int = 3) -> str:
        """Delegates to geometry_utils module."""
        return format_shape_refs_for_error(label, refs, max_items)

    def _collect_feature_reference_diagnostics(self, feature, max_parts: int = 6) -> str:
        """Delegates to geometry_utils module."""
        return collect_feature_reference_diagnostics(feature, max_parts)

    @staticmethod
    def _collect_feature_reference_payload(feature) -> dict:
        """Delegates to geometry_utils module."""
        return collect_feature_reference_payload(feature)

    def _record_tnp_failure(
        self,
        *,
        feature,
        category: str,
        reference_kind: str,
        reason: str,
        expected: Optional[int] = None,
        resolved: Optional[int] = None,
        strict: bool = False,
    ) -> None:
        """Merkt die letzte TNP-Fehlerkategorie, damit _safe_operation sie envelope-n kann."""
        if feature is None:
            self._pending_tnp_failure = None
            return

        category_norm = str(category or "").strip().lower() or "missing_ref"
        if category_norm not in {"missing_ref", "mismatch", "drift"}:
            category_norm = "missing_ref"

        kind_norm = str(reference_kind or "").strip().lower() or "reference"
        next_action_map = {
            "missing_ref": f"{kind_norm.capitalize()}-Referenz neu waehlen und Feature erneut ausfuehren.",
            "mismatch": f"{kind_norm.capitalize()}-ShapeID und Index stimmen nicht ueberein. Referenz neu waehlen.",
            "drift": "Referenzierte Geometrie ist gedriftet. Feature mit kleineren Werten erneut anwenden.",
        }

        payload = {
            "category": category_norm,
            "reference_kind": kind_norm,
            "reason": str(reason or "").strip() or "unspecified",
            "strict": bool(strict),
            "next_action": next_action_map.get(
                category_norm,
                "Referenzen pruefen und Feature erneut ausfuehren.",
            ),
            "feature_id": getattr(feature, "id", ""),
            "feature_name": getattr(feature, "name", ""),
            "feature_class": feature.__class__.__name__,
        }
        if expected is not None:
            try:
                payload["expected"] = max(0, int(expected))
            except Exception:
                pass
        if resolved is not None:
            try:
                payload["resolved"] = max(0, int(resolved))
            except Exception:
                pass
        self._pending_tnp_failure = payload

    def _consume_tnp_failure(self, feature=None) -> Optional[dict]:
        """Liefert und leert die letzte TNP-Fehlerkategorie (feature-gebunden)."""
        pending = self._pending_tnp_failure
        self._pending_tnp_failure = None
        if not pending:
            return None
        if feature is None:
            return dict(pending)

        pending_feature_id = str(pending.get("feature_id") or "")
        feature_id = str(getattr(feature, "id", "") or "")
        if pending_feature_id and feature_id and pending_feature_id != feature_id:
            return None
        return dict(pending)

    @staticmethod
    def _classify_error_code(error_code: str) -> tuple[str, str]:
        """Mappt Error-Code auf stabile Envelope-Klassen fuer UI/QA."""
        code_norm = str(error_code or "").strip().lower()
        warning_codes = {
            "fallback_used",
            "tnp_ref_drift",
        }
        blocked_codes = {
            "blocked_by_upstream_error",
            "fallback_blocked_strict",
        }
        critical_codes = {
            "rebuild_finalize_failed",
        }
        if code_norm in critical_codes:
            return "CRITICAL", "critical"
        if code_norm in warning_codes:
            return "WARNING_RECOVERABLE", "warning"
        if code_norm in blocked_codes:
            return "BLOCKED", "blocked"
        return "ERROR", "error"

    @staticmethod
    def _default_next_action_for_code(error_code: str) -> str:
        defaults = {
            "operation_failed": "Parameter pruefen oder Referenz neu auswaehlen und erneut ausfuehren.",
            "fallback_used": "Ergebnis wurde via Fallback erzeugt. Geometrie pruefen und Parameter/Referenz ggf. nachziehen.",
            "fallback_failed": "Feature vereinfachen und mit kleineren Werten erneut versuchen.",
            "fallback_blocked_strict": "Feature neu referenzieren oder self_heal_strict deaktivieren.",
            "blocked_by_upstream_error": "Zuerst das vorherige fehlgeschlagene Feature beheben.",
            "no_result_solid": "Eingaben/Referenzen pruefen, da kein Ergebnis-Solid erzeugt wurde.",
            "self_heal_rollback_invalid_result": "Featureparameter reduzieren oder Referenzflaeche anpassen.",
            "self_heal_rollback_geometry_drift": "Lokalen Modifier mit kleineren Werten erneut anwenden.",
            "self_heal_blocked_topology_warning": "Topologie-Referenzen pruefen und Feature neu auswaehlen.",
            "tnp_ref_missing": "Topologie-Referenz neu waehlen und Rebuild erneut ausfuehren.",
            "tnp_ref_mismatch": "ShapeID/Index-Referenz stimmt nicht ueberein. Referenz neu waehlen.",
            "tnp_ref_drift": "Referenzierte Geometrie ist gedriftet. Feature mit kleineren Werten erneut anwenden.",
            "rebuild_finalize_failed": "Rebuild erneut ausfuehren oder letzte stabile Aenderung rueckgaengig machen.",
            "ocp_api_unavailable": "OCP-Build pruefen oder alternative Operation verwenden.",
        }
        return defaults.get(
            error_code,
            "Fehlerdetails pruefen und den letzten gueltigen Bearbeitungsschritt wiederholen.",
        )

    @classmethod
    def _normalize_status_details_for_load(cls, status_details: Any) -> dict:
        """
        Backward-Compat fuer persistierte status_details.

        Legacy-Dateien koennen `code` ohne `status_class`/`severity` enthalten.
        Beim Laden werden diese Felder deterministisch nachgezogen.
        """
        if not isinstance(status_details, dict):
            return {}

        normalized = dict(status_details)
        code = str(normalized.get("code", "") or "").strip()
        if code:
            normalized.setdefault("schema", "error_envelope_v1")
        has_status_class = bool(str(normalized.get("status_class", "") or "").strip())
        has_severity = bool(str(normalized.get("severity", "") or "").strip())
        if code and (not has_status_class or not has_severity):
            status_class, severity = cls._classify_error_code(code)
            normalized.setdefault("status_class", status_class)
            normalized.setdefault("severity", severity)

        hint = str(normalized.get("hint", "") or "").strip()
        next_action = str(normalized.get("next_action", "") or "").strip()
        if hint and not next_action:
            normalized["next_action"] = hint
            next_action = hint
        if next_action and not hint:
            normalized["hint"] = next_action
            hint = next_action
        if code and not hint and not next_action:
            action = cls._default_next_action_for_code(code)
            if action:
                normalized["hint"] = action
                normalized["next_action"] = action
        return normalized

    def _build_operation_error_details(
        self,
        *,
        op_name: str,
        code: str,
        message: str,
        feature=None,
        hint: str = "",
        fallback_error: str = "",
    ) -> dict:
        status_class, severity = self._classify_error_code(code)
        details = {
            "schema": "error_envelope_v1",
            "code": code,
            "operation": op_name,
            "message": message,
            "status_class": status_class,
            "severity": severity,
        }
        if feature is not None:
            details["feature"] = {
                "id": getattr(feature, "id", ""),
                "name": getattr(feature, "name", ""),
                "class": feature.__class__.__name__,
            }
        refs = self._collect_feature_reference_payload(feature)
        if refs:
            details["refs"] = refs
        next_action = hint or self._default_next_action_for_code(code)
        if next_action:
            details["hint"] = next_action
            details["next_action"] = next_action
        if fallback_error:
            details["fallback_error"] = fallback_error
        return details

    def _safe_operation(self, op_name, op_func, fallback_func=None, feature=None):
        """
        Wrapper fÃ¼r kritische CAD-Operationen.
        FÃ¤ngt Crashes ab und erlaubt Fallbacks.
        """
        try:
            self._last_operation_error = ""
            self._last_operation_error_details = {}
            self._pending_tnp_failure = None
            result = op_func()
            
            if result is None:
                raise ValueError("Operation returned None")
            
            if hasattr(result, 'is_valid') and not result.is_valid():
                raise ValueError("Result geometry is invalid")

            tnp_notice = self._consume_tnp_failure(feature)
            notice_category = (
                str((tnp_notice or {}).get("category") or "").strip().lower()
                if isinstance(tnp_notice, dict)
                else ""
            )
            if notice_category == "drift":
                notice_reason = str(tnp_notice.get("reason") or "").strip()
                notice_msg = "TNP-Referenzdrift erkannt; Geometric-Fallback wurde verwendet."
                if notice_reason:
                    notice_msg = f"{notice_msg} reason={notice_reason}"
                self._last_operation_error = notice_msg
                drift_hint = str(tnp_notice.get("next_action") or "").strip()
                self._last_operation_error_details = self._build_operation_error_details(
                    op_name=op_name,
                    code="tnp_ref_drift",
                    message=notice_msg,
                    feature=feature,
                    hint=drift_hint,
                )
                self._last_operation_error_details["tnp_failure"] = tnp_notice
                return result, "WARNING"

            return result, "SUCCESS"
            
        except Exception as e:
            err_msg = str(e).strip() or e.__class__.__name__
            ref_diag = self._collect_feature_reference_diagnostics(feature)
            if ref_diag and "refs:" not in err_msg:
                err_msg = f"{err_msg} | refs: {ref_diag}"
            self._last_operation_error = err_msg
            tnp_failure = self._consume_tnp_failure(feature)
            tnp_code_by_category = {
                "missing_ref": "tnp_ref_missing",
                "mismatch": "tnp_ref_mismatch",
                "drift": "tnp_ref_drift",
            }
            tnp_category = (
                str((tnp_failure or {}).get("category") or "").strip().lower()
                if isinstance(tnp_failure, dict)
                else ""
            )
            error_code = tnp_code_by_category.get(tnp_category, "operation_failed")
            dependency_error = None
            if error_code == "operation_failed":
                dep_msg = str(e).strip() or e.__class__.__name__
                dep_msg_lower = dep_msg.lower()
                is_direct_dep_error = isinstance(e, (ImportError, ModuleNotFoundError, AttributeError))
                ocp_markers = (
                    "ocp",
                    "no module named 'ocp",
                    "cannot import name",
                    "has no attribute",
                )
                is_ocp_dependency_error = is_direct_dep_error and any(marker in dep_msg_lower for marker in ocp_markers)
                if (not is_ocp_dependency_error) and any(marker in dep_msg_lower for marker in ("cannot import name", "no module named", "has no attribute")):
                    # Wrapped dependency error (e.g. RuntimeError with import text)
                    is_ocp_dependency_error = "ocp" in dep_msg_lower
                if is_ocp_dependency_error:
                    error_code = "ocp_api_unavailable"
                    dependency_error = {
                        "kind": "ocp_api",
                        "exception": e.__class__.__name__,
                        "detail": dep_msg,
                    }
            tnp_hint = ""
            if isinstance(tnp_failure, dict):
                tnp_hint = str(tnp_failure.get("next_action") or "").strip()
            self._last_operation_error_details = self._build_operation_error_details(
                op_name=op_name,
                code=error_code,
                message=err_msg,
                feature=feature,
                hint=tnp_hint,
            )
            if isinstance(tnp_failure, dict):
                self._last_operation_error_details["tnp_failure"] = tnp_failure
            if dependency_error:
                self._last_operation_error_details["runtime_dependency"] = dependency_error
            logger.warning(f"Feature '{op_name}' fehlgeschlagen: {err_msg}")
            
            if fallback_func:
                strict_self_heal = is_enabled("self_heal_strict")
                strict_topology_policy = is_enabled("strict_topology_fallback_policy")
                has_topology_refs = self._feature_has_topological_references(feature) if feature is not None else False
                if has_topology_refs and (strict_self_heal or strict_topology_policy):
                    policy_reason = (
                        "Strict Self-Heal"
                        if strict_self_heal
                        else "strict_topology_fallback_policy"
                    )
                    self._last_operation_error = (
                        f"PrimÃ¤rpfad fehlgeschlagen: {err_msg}; "
                        f"{policy_reason} blockiert Fallback bei Topologie-Referenzen"
                    )
                    self._last_operation_error_details = self._build_operation_error_details(
                        op_name=op_name,
                        code="fallback_blocked_strict",
                        message=self._last_operation_error,
                        feature=feature,
                        hint="Feature neu referenzieren oder Parameter reduzieren.",
                    )
                    if isinstance(tnp_failure, dict):
                        self._last_operation_error_details["tnp_failure"] = tnp_failure
                    logger.error(
                        f"{policy_reason}: Fallback fÃ¼r '{op_name}' blockiert "
                        "(Topologie-Referenzen aktiv)."
                    )
                    return None, "ERROR"
                logger.debug(f"â†’ Versuche Fallback fÃ¼r '{op_name}'...")
                try:
                    res_fallback = fallback_func()
                    if res_fallback:
                        self._last_operation_error = f"PrimÃ¤rpfad fehlgeschlagen: {err_msg}; Fallback wurde verwendet"
                        self._last_operation_error_details = self._build_operation_error_details(
                            op_name=op_name,
                            code="fallback_used",
                            message=self._last_operation_error,
                            feature=feature,
                        )
                        logger.debug(f"âœ“ Fallback fÃ¼r '{op_name}' erfolgreich.")
                        return res_fallback, "WARNING"
                except Exception as e2:
                    fallback_msg = str(e2).strip() or e2.__class__.__name__
                    self._last_operation_error = (
                        f"PrimÃ¤rpfad fehlgeschlagen: {err_msg}; Fallback fehlgeschlagen: {fallback_msg}"
                    )
                    self._last_operation_error_details = self._build_operation_error_details(
                        op_name=op_name,
                        code="fallback_failed",
                        message=self._last_operation_error,
                        feature=feature,
                        fallback_error=fallback_msg,
                    )
                    logger.error(f"âœ— Auch Fallback fehlgeschlagen: {fallback_msg}")
            
            return None, "ERROR"

    def _register_boolean_history(self, bool_result: BooleanResult, feature, operation_name: str = ""):
        """
        Registriert Boolean-History fÃ¼r TNP v4.0.

        Wird nach erfolgreichen Boolean-Operationen aufgerufen um
        die BRepTools_History an die TNP-Systeme weiterzugeben.

        Args:
            bool_result: BooleanResult mit history-Attribut
            feature: Das Feature das die Boolean-Operation ausgelÃ¶st hat
            operation_name: Name der Operation (Join/Cut/Intersect)
        """
        boolean_history = getattr(bool_result, 'history', None)
        if boolean_history is None:
            return

        # TNP v4.0: ShapeNamingService
        if self._document and hasattr(self._document, '_shape_naming_service'):
            try:
                service = self._document._shape_naming_service
                service.record_operation(
                    OperationRecord(
                        operation_id=str(uuid.uuid4())[:8],
                        operation_type=f"BOOLEAN_{operation_name.upper()}",
                        feature_id=getattr(feature, 'id', 'unknown'),
                        occt_history=boolean_history,
                    )
                )
                if is_enabled("tnp_debug_logging"):
                    logger.debug(f"TNP v4.0: Boolean {operation_name} History registriert")
            except Exception as tnp_e:
                if is_enabled("tnp_debug_logging"):
                    logger.debug(f"TNP v4.0 History-Registrierung fehlgeschlagen: {tnp_e}")

    def _register_fillet_chamfer_history(self, result_solid, history, feature, operation_type: str = "FILLET"):
        """
        Registriert Fillet/Chamfer History fÃ¼r TNP v4.0.

        Phase 12: Nutzt BRepFilletAPI_MakeFillet.History() fÃ¼r prÃ¤zises Shape-Tracking
        nach Fillet/Chamfer-Operationen.

        Args:
            result_solid: Das resultierende Build123d Solid
            history: BRepTools_History von der Fillet/Chamfer-Operation
            feature: Das FilletFeature/ChamferFeature
            operation_type: "FILLET" oder "CHAMFER"
        """
        if history is None:
            return

        # TNP v4.0: ShapeNamingService
        if self._document and hasattr(self._document, '_shape_naming_service'):
            try:
                service = self._document._shape_naming_service
                service.record_operation(
                    OperationRecord(
                        operation_id=str(uuid.uuid4())[:8],
                        operation_type=operation_type,
                        feature_id=getattr(feature, 'id', 'unknown'),
                        occt_history=history,
                    )
                )
                if is_enabled("tnp_debug_logging"):
                    logger.debug(f"TNP v4.0: {operation_type} History registriert")
            except Exception as tnp_e:
                if is_enabled("tnp_debug_logging"):
                    logger.debug(f"TNP v4.0 {operation_type} History-Registrierung fehlgeschlagen: {tnp_e}")

    @staticmethod
    def _build_history_from_make_shape(make_shape_op, input_shape):
        """
        Baut ein BRepTools_History aus einer BRepBuilderAPI_MakeShape-Operation.

        Phase 12: BRepFilletAPI_MakeFillet/MakeChamfer erben von BRepBuilderAPI_MakeShape
        und haben Generated()/Modified()/IsDeleted() aber kein direktes History().
        Diese Methode konstruiert die History manuell.

        Args:
            make_shape_op: BRepBuilderAPI_MakeShape (z.B. BRepFilletAPI_MakeFillet)
            input_shape: Das Original-Shape vor der Operation

        Returns:
            BRepTools_History mit allen Zuordnungen
        """
        from OCP.BRepTools import BRepTools_History
        from OCP.TopExp import TopExp_Explorer
        from OCP.TopAbs import TopAbs_EDGE, TopAbs_FACE, TopAbs_VERTEX

        history = BRepTools_History()

        for shape_type in (TopAbs_FACE, TopAbs_EDGE, TopAbs_VERTEX):
            explorer = TopExp_Explorer(input_shape, shape_type)
            count = 0
            while explorer.More():
                count += 1
                sub_shape = explorer.Current()
                
                # Helper to check history for a shape and its reverse
                def _check_and_add(s):
                    # Generated
                    try:
                        gen = list(make_shape_op.Generated(s))
                        if gen:
                            if is_enabled("tnp_debug_logging"):
                                 logger.debug(f"TNP History: Generated for {s} (Ori={s.Orientation()}): {len(gen)} items")
                            for res in gen:
                                history.AddGenerated(sub_shape, res) # Always map FROM the original sub_shape
                    except Exception:
                        pass
                    
                    # Modified
                    try:
                        mod = list(make_shape_op.Modified(s))
                        if mod:
                            if is_enabled("tnp_debug_logging"):
                                 logger.debug(f"TNP History: Modified for {s} (Ori={s.Orientation()}): {len(mod)} items")
                            for res in mod:
                                history.AddModified(sub_shape, res)
                    except Exception:
                        pass
                        
                    # Deleted
                    try:
                        if make_shape_op.IsDeleted(s):
                            if is_enabled("tnp_debug_logging"):
                                 logger.debug(f"TNP History: Deleted {s} (Ori={s.Orientation()})")
                            history.Remove(sub_shape)
                    except Exception:
                        pass

                _check_and_add(sub_shape)
                if sub_shape.Orientation() != 0: # Check reverse only if orientation is not "EXTERNAL" (0)? TopAbs orientation is enum.
                     # TopAbs_FORWARD=0, TopAbs_REVERSED=1. 
                     # Safe to just check Reversed() always.
                     _check_and_add(sub_shape.Reversed())
                
                explorer.Next()
            
            if is_enabled("tnp_debug_logging"):
                 logger.debug(f"TNP History: Scanned {count} items of type {shape_type}")

        return history

        return history

    def _fix_shape_ocp(self, shape):
        """Repariert einen TopoDS_Shape mit OCP ShapeFix."""
        try:
            from OCP.ShapeFix import ShapeFix_Shape, ShapeFix_Solid
            from OCP.BRepCheck import BRepCheck_Analyzer

            # PrÃ¼fe ob Shape valide ist
            analyzer = BRepCheck_Analyzer(shape)
            if analyzer.IsValid():
                return shape

            logger.debug("Shape invalid, starte Reparatur...")

            # ShapeFix_Shape fÃ¼r allgemeine Reparaturen - Phase 5: Zentralisierte Toleranzen
            fixer = ShapeFix_Shape(shape)
            fixer.SetPrecision(Tolerances.KERNEL_PRECISION)
            fixer.SetMaxTolerance(Tolerances.MESH_EXPORT)
            fixer.SetMinTolerance(Tolerances.KERNEL_PRECISION / 10)

            # HINWEIS: FixSolidMode() etc. sind GETTER, nicht Setter!
            # Die Standardwerte sind bereits True fÃ¼r die meisten Modi.
            # Wir verlassen uns auf die Defaults.

            if fixer.Perform():
                fixed_shape = fixer.Shape()

                # Validiere repariertes Shape
                analyzer2 = BRepCheck_Analyzer(fixed_shape)
                if analyzer2.IsValid():
                    logger.debug("âœ“ Shape repariert")
                    return fixed_shape
                else:
                    logger.warning("Shape nach Reparatur immer noch invalid")
                    # Gib es trotzdem zurÃ¼ck - manchmal funktioniert es dennoch
                    return fixed_shape
            else:
                logger.warning("ShapeFix Perform() fehlgeschlagen")
                return shape  # Gib Original zurÃ¼ck

        except Exception as e:
            logger.warning(f"Shape-Reparatur Fehler: {e}")
            return shape  # Gib Original zurÃ¼ck

    # ==================== PHASE 6: COMPUTE METHODS ====================
    # NOTE: _ocp_fillet und _ocp_chamfer wurden in OCP-AMP2 entfernt
    # (Doppelte Implementierungen, werden durch OCPFilletHelper/OCPChamferHelper ersetzt)

    # ==================== PHASE 6: COMPUTE METHODS ====================

    def _compute_sweep(self, feature: 'SweepFeature', current_solid):
        """
        Berechnet Sweep eines Profils entlang eines Pfads.

        OCP-First Strategy:
        1. Profil zu Face konvertieren + Pfad auflÃ¶sen
        2. Voranalyse: Pfad-KomplexitÃ¤t â†’ MakePipe oder MakePipeShell
        3. Kein Fallback - bei Fehler ValueError

        Phase 8: UnterstÃ¼tzt Twist und Skalierung
        """
        profile_face = None
        shape_service = None
        if self._document and hasattr(self._document, '_shape_naming_service'):
            shape_service = self._document._shape_naming_service

        profile_data = feature.profile_data if isinstance(feature.profile_data, dict) else {}
        profile_source_solid = current_solid
        profile_body_id = profile_data.get("body_id")
        if profile_body_id and self._document and hasattr(self._document, "find_body_by_id"):
            try:
                profile_body = self._document.find_body_by_id(profile_body_id)
                if profile_body is not None and getattr(profile_body, "_build123d_solid", None) is not None:
                    profile_source_solid = profile_body._build123d_solid
            except Exception as e:
                logger.debug(f"Sweep: Konnte Profil-Body '{profile_body_id}' nicht laden: {e}")

        profile_face_index = getattr(feature, "profile_face_index", None)
        try:
            profile_face_index = int(profile_face_index) if profile_face_index is not None else None
        except Exception:
            profile_face_index = None
        if profile_face_index is not None and profile_face_index < 0:
            profile_face_index = None
        feature.profile_face_index = profile_face_index

        has_profile_shape_ref = feature.profile_shape_id is not None
        has_topological_profile_refs = bool(has_profile_shape_ref or profile_face_index is not None)

        def _is_same_face(face_a, face_b) -> bool:
            if face_a is None or face_b is None:
                return False
            try:
                wa = face_a.wrapped if hasattr(face_a, "wrapped") else face_a
                wb = face_b.wrapped if hasattr(face_b, "wrapped") else face_b
                return wa.IsSame(wb)
            except Exception:
                return face_a is face_b

        def _persist_profile_shape_id(face_obj) -> None:
            if (
                face_obj is None
                or not shape_service
                or feature.profile_shape_id is not None
                or not hasattr(face_obj, "wrapped")
            ):
                return
            try:
                from modeling.tnp_system import ShapeType as TNPShapeType
                shape_id = shape_service.find_shape_id_by_face(face_obj)
                if shape_id is None:
                    fc = face_obj.center()
                    area = face_obj.area if hasattr(face_obj, "area") else 0.0
                    shape_id = shape_service.register_shape(
                        ocp_shape=face_obj.wrapped,
                        shape_type=TNPShapeType.FACE,
                        feature_id=feature.id,
                        local_index=max(0, int(profile_face_index) if profile_face_index is not None else 0),
                        geometry_data=(fc.X, fc.Y, fc.Z, area),
                    )
                if shape_id is not None:
                    feature.profile_shape_id = shape_id
            except Exception as e:
                logger.debug(f"Sweep: Konnte Profil-ShapeID nicht persistieren: {e}")

        profile_face_from_index = None
        if profile_source_solid is not None and profile_face_index is not None:
            try:
                from modeling.topology_indexing import face_from_index

                profile_face_from_index = face_from_index(profile_source_solid, profile_face_index)
                if profile_face_from_index is not None:
                    profile_face = profile_face_from_index
                    _persist_profile_shape_id(profile_face_from_index)
                    if is_enabled("tnp_debug_logging"):
                        logger.debug(f"Sweep: Profil via Face-Index aufgelÃ¶st (index={profile_face_index})")
            except Exception as e:
                logger.debug(f"Sweep: Profil-Index AuflÃ¶sung fehlgeschlagen: {e}")

        profile_face_from_shape = None
        profile_shape_resolution_method = ""
        if profile_source_solid is not None and has_profile_shape_ref and shape_service:
            try:
                resolved_ocp, method = shape_service.resolve_shape_with_method(
                    feature.profile_shape_id, profile_source_solid
                )
                profile_shape_resolution_method = str(method or "").strip().lower()
                if resolved_ocp is not None:
                    from build123d import Face
                    from modeling.topology_indexing import face_index_of

                    profile_face_from_shape = Face(resolved_ocp)
                    resolved_idx = face_index_of(profile_source_solid, profile_face_from_shape)
                    if resolved_idx is not None:
                        feature.profile_face_index = int(resolved_idx)
                    if profile_face is None:
                        profile_face = profile_face_from_shape
                    if is_enabled("tnp_debug_logging"):
                        logger.debug(f"Sweep: Profil via ShapeID aufgelÃ¶st (method={method})")
            except Exception as e:
                logger.debug(f"Sweep: Profil-ShapeID AuflÃ¶sung fehlgeschlagen: {e}")

        if has_profile_shape_ref and profile_face_index is not None:
            single_profile_ref_pair = True
            if profile_face_from_index is None or profile_face_from_shape is None:
                index_resolved = profile_face_from_index is not None
                shape_resolved = profile_face_from_shape is not None
                if single_profile_ref_pair and index_resolved and (not shape_resolved):
                    feature.profile_shape_id = None
                    if profile_face_index is not None:
                        feature.profile_face_index = int(profile_face_index)
                    _persist_profile_shape_id(profile_face_from_index)
                    profile_face = profile_face_from_index
                    if is_enabled("tnp_debug_logging"):
                        logger.warning(
                            "Sweep: single_ref_pair profile ShapeID nicht aufloesbar -> "
                            "verwende index-basiertes Profil."
                        )
                else:
                    self._record_tnp_failure(
                        feature=feature,
                        category="missing_ref",
                        reference_kind="face",
                        reason="sweep_profile_unresolved_topology_reference",
                        expected=2,
                        resolved=int(index_resolved) + int(shape_resolved),
                        strict=True,
                    )
                    raise ValueError(
                        "Sweep: Profil-Referenz ist inkonsistent "
                        "(profile_shape_id/profile_face_index). Bitte Profil neu auswÃ¤hlen."
                    )
            if (
                profile_face_from_index is not None
                and profile_face_from_shape is not None
                and not _is_same_face(profile_face_from_index, profile_face_from_shape)
            ):
                weak_shape_resolution = profile_shape_resolution_method in {"geometric", "geometry_hash"}
                if single_profile_ref_pair and weak_shape_resolution:
                    feature.profile_shape_id = None
                    if profile_face_index is not None:
                        feature.profile_face_index = int(profile_face_index)
                    _persist_profile_shape_id(profile_face_from_index)
                    profile_face = profile_face_from_index
                    self._record_tnp_failure(
                        feature=feature,
                        category="drift",
                        reference_kind="face",
                        reason="single_ref_pair_geometric_shape_conflict_index_preferred",
                        expected=1,
                        resolved=1,
                        strict=False,
                    )
                    if is_enabled("tnp_debug_logging"):
                        logger.warning(
                            "Sweep: single_ref_pair Profile Shape/Index-Konflikt mit schwacher "
                            "Shape-Aufloesung (geometric/hash) -> index-basiertes Profil bevorzugt."
                        )
                else:
                    self._record_tnp_failure(
                        feature=feature,
                        category="mismatch",
                        reference_kind="face",
                        reason="sweep_profile_shape_index_mismatch",
                        expected=2,
                        resolved=2,
                        strict=True,
                    )
                    raise ValueError(
                        "Sweep: Profil-Referenz ist inkonsistent "
                        "(profile_shape_id != profile_face_index). Bitte Profil neu auswÃ¤hlen."
                    )
            profile_face = profile_face_from_index

        if profile_face is None and has_topological_profile_refs:
            logger.warning(
                "Sweep: TNP-Profilreferenz konnte nicht aufgelÃ¶st werden "
                "(profile_shape_id/profile_face_index). Kein Geometric-Fallback."
            )
            self._record_tnp_failure(
                feature=feature,
                category="missing_ref",
                reference_kind="face",
                reason="sweep_profile_unresolved_topology_reference",
                expected=1,
                resolved=0,
                strict=True,
            )
            raise ValueError("Sweep: Profil-Referenz ist ungÃ¼ltig. Bitte Profil neu auswÃ¤hlen.")

        # TNP v4.0 Fallback: GeometricFaceSelector (nur wenn keine topologischen Refs vorhanden)
        if profile_face is None and profile_source_solid is not None and feature.profile_geometric_selector:
            try:
                from modeling.geometric_selector import GeometricFaceSelector
                from modeling.topology_indexing import face_index_of

                selectors = [feature.profile_geometric_selector]
                if isinstance(feature.profile_geometric_selector, list):
                    selectors = feature.profile_geometric_selector

                all_faces = list(profile_source_solid.faces()) if hasattr(profile_source_solid, 'faces') else []
                for selector_data in selectors:
                    if isinstance(selector_data, dict):
                        geo_sel = GeometricFaceSelector.from_dict(selector_data)
                    elif hasattr(selector_data, 'find_best_match'):
                        geo_sel = selector_data
                    else:
                        continue

                    best_face = geo_sel.find_best_match(all_faces)
                    if best_face is not None:
                        profile_face = best_face
                        feature.profile_face_index = face_index_of(profile_source_solid, profile_face)
                        _persist_profile_shape_id(profile_face)
                        break
            except Exception as e:
                logger.debug(f"Sweep: Profil Ã¼ber GeometricSelector fehlgeschlagen: {e}")

        # Legacy-Fallback: Profil aus gespeicherten Geometriedaten (Sketch-Profil)
        if profile_face is None:
            profile_face = self._profile_data_to_face(feature.profile_data)
        if profile_face is None:
            raise ValueError("Konnte Profil-Face nicht erstellen")

        # Pfad auflÃ¶sen
        path_wire = self._resolve_path(feature.path_data, current_solid, feature)
        if path_wire is None:
            raise ValueError("Konnte Pfad nicht auflÃ¶sen")

        # WICHTIG: Profil zum Pfad-Start verschieben
        # FÃ¼r Sweep muss das Profil am Startpunkt des Pfads liegen!
        profile_face = self._move_profile_to_path_start(profile_face, path_wire, feature)

        # OCP-First Sweep mit Voranalyse fÃ¼r optimale Methode
        # Keine Fallback-Kaskade - entweder OCP erfolgreich oder Fehler
        twist_angle = getattr(feature, 'twist_angle', 0.0)
        scale_start = getattr(feature, 'scale_start', 1.0)
        scale_end = getattr(feature, 'scale_end', 1.0)
        has_twist_or_scale = (twist_angle != 0.0 or scale_start != 1.0 or scale_end != 1.0)

        logger.debug(f"Sweep OCP-First: Frenet={feature.is_frenet}, Twist={twist_angle}Â°, Scale={scale_start}->{scale_end}")

        # Voranalyse: Pfad-KomplexitÃ¤t bestimmen
        is_curved_path = self._is_curved_path(path_wire)
        has_spine = hasattr(feature, 'spine') and feature.spine is not None

        # OCP-Importe
        from OCP.BRepOffsetAPI import BRepOffsetAPI_MakePipe, BRepOffsetAPI_MakePipeShell
        from OCP.GeomFill import GeomFill_IsCorrectedFrenet, GeomFill_IsConstantNormal
        from OCP.BRepBuilderAPI import BRepBuilderAPI_MakeWire
        from OCP.TopExp import TopExp_Explorer
        from OCP.TopAbs import TopAbs_EDGE
        from build123d import Solid

        face_shape = profile_face.wrapped if hasattr(profile_face, 'wrapped') else profile_face
        path_shape = path_wire.wrapped if hasattr(path_wire, 'wrapped') else path_wire

        # Validierung: Shape muss OCP-TopoDS_Shape sein
        if path_shape is None:
            raise ValueError("Sweep: Pfad ist None")
        type_name = type(path_shape).__name__
        if 'TopoDS' not in type_name and path_shape.__class__.__module__ != 'OCP.TopoDS':
            raise ValueError(f"Sweep: Pfad ist kein OCP Shape (Typ: {type_name})")

        # Profil-Wire extrahieren (fÃ¼r MakePipeShell)
        # Versuche build123d outer_wire zuerst, dann OCP Fallback
        profile_wire = None
        if hasattr(profile_face, 'outer_wire'):
            try:
                profile_wire = profile_face.outer_wire()
                if hasattr(profile_wire, 'wrapped'):
                    profile_wire = profile_wire.wrapped
            except Exception as e:
                logger.debug(f"Sweep: outer_wire() fehlgeschlagen: {e}")

        # Fallback: OCP Wire-Building aus Edges
        if profile_wire is None:
            explorer = TopExp_Explorer(face_shape, TopAbs_EDGE)
            profile_wire_builder = BRepBuilderAPI_MakeWire()
            while explorer.More():
                try:
                    profile_wire_builder.Add(explorer.Current())
                except Exception:
                    pass
                explorer.Next()

            if not profile_wire_builder.IsDone():
                raise ValueError("Sweep: Profil-Wire Extraktion fehlgeschlagen")
            profile_wire = profile_wire_builder.Wire()

        # OCP-First: Einziger Pfad mit Methoden-Wahl
        result_shape = None

        # Einfacher Pfad â†’ MakePipe (schneller, zuverlÃ¤ssiger)
        if not is_curved_path and not has_twist_or_scale and not feature.is_frenet and not has_spine:
            logger.debug("Sweep: Verwende MakePipe (einfacher Pfad)")
            pipe_op = BRepOffsetAPI_MakePipe(path_shape, face_shape)
            pipe_op.Build()

            if not pipe_op.IsDone():
                raise ValueError("Sweep MakePipe fehlgeschlagen: IsDone()=False")

            result_shape = pipe_op.Shape()

        # Komplexer Pfad oder Twist/Scale â†’ MakePipeShell
        else:
            logger.debug(f"Sweep: Verwende MakePipeShell (curved={is_curved_path}, frenet={feature.is_frenet}, twist/scale={has_twist_or_scale})")
            pipe_shell = BRepOffsetAPI_MakePipeShell(path_shape)

            # Trihedron-Mode setzen
            if feature.is_frenet:
                pipe_shell.SetMode(GeomFill_IsCorrectedFrenet)
            else:
                pipe_shell.SetMode(GeomFill_IsConstantNormal)

            # Advanced: Twist/Scale mit Law-Funktionen
            if has_twist_or_scale:
                try:
                    from OCP.Law import Law_Linear

                    # Scale-Law erstellen
                    if scale_start != 1.0 or scale_end != 1.0:
                        scale_law = Law_Linear()
                        scale_law.Set(0.0, scale_start, 1.0, scale_end)
                        pipe_shell.SetLaw(profile_wire, scale_law, False, False)
                        logger.debug(f"Sweep: Scale-Law {scale_start}->{scale_end} angewendet")
                    else:
                        pipe_shell.Add(profile_wire, False, False)

                    # Twist wird Ã¼ber Approximation realisiert
                    if twist_angle != 0.0:
                        logger.info(f"Sweep: Twist {twist_angle}Â° wird approximiert")
                        # VollstÃ¤ndige Twist-Implementierung wÃ¼rde Law_Interpol benÃ¶tigen
                except ImportError:
                    logger.debug("OCP.Law nicht verfÃ¼gbar, Standard-Add verwenden")
                    pipe_shell.Add(profile_wire, False, False)
            else:
                pipe_shell.Add(profile_wire, False, False)

            pipe_shell.Build()

            if not pipe_shell.IsDone():
                raise ValueError("Sweep MakePipeShell fehlgeschlagen: IsDone()=False")

            try:
                pipe_shell.MakeSolid()
            except Exception:
                pass  # MakeSolid optional fÃ¼r geschlossene Profile

            result_shape = pipe_shell.Shape()

        # Shape-Fix und Validierung
        result_shape = self._fix_shape_ocp(result_shape)
        result = Solid(result_shape)

        if not result.is_valid():
            raise ValueError("Sweep erzeugte keinen gÃ¼ltigen Solid")

        # TNP-Registration wenn naming_service verfÃ¼gbar
        if self._document and hasattr(self._document, '_shape_naming_service'):
            try:
                naming_service = self._document._shape_naming_service
                feature_id = getattr(feature, 'id', None) or str(id(feature))

                # Alle Faces registrieren
                from modeling.tnp_system import ShapeType
                from OCP.TopExp import TopExp_Explorer
                from OCP.TopAbs import TopAbs_FACE

                explorer = TopExp_Explorer(result_shape, TopAbs_FACE)
                face_idx = 0
                while explorer.More():
                    ocp_face = explorer.Current()
                    fc = self._get_face_center(ocp_face)
                    area = self._get_face_area(ocp_face)
                    naming_service.register_shape(
                        ocp_shape=ocp_face,
                        shape_type=ShapeType.FACE,
                        feature_id=feature_id,
                        local_index=face_idx,
                        geometry_data=(fc.X, fc.Y, fc.Z, area),
                    )
                    face_idx += 1
                    explorer.Next()

                logger.debug(f"Sweep: {face_idx} Faces registriert")
            except Exception as e:
                logger.debug(f"Sweep TNP-Registration fehlgeschlagen: {e}")

        logger.debug("Sweep OCP-First erfolgreich")
        return result

    def _move_profile_to_path_start(self, profile_face, path_wire, feature):
        """
        Verschiebt das Profil zum Startpunkt des Pfads.

        In CAD-Systemen wie CAD muss das Profil am Pfad-Start liegen.
        Diese Funktion berechnet die notwendige Translation und wendet sie an.

        Args:
            profile_face: Build123d Face (Profil)
            path_wire: Build123d Wire (Pfad)
            feature: SweepFeature mit profile_data

        Returns:
            Verschobenes Build123d Face
        """
        try:
            from build123d import Vector, Location
            import numpy as np

            # Pfad-Startpunkt ermitteln
            path_edges = path_wire.edges() if hasattr(path_wire, 'edges') else []
            if not path_edges:
                logger.warning("Sweep: Pfad hat keine Edges, Ã¼berspringe Profil-Verschiebung")
                return profile_face

            first_edge = path_edges[0]

            # Startpunkt der ersten Edge
            # In OCP: Edge.first_vertex().center()
            if hasattr(first_edge, 'start_point'):
                path_start = first_edge.start_point()
            elif hasattr(first_edge, 'position_at'):
                path_start = first_edge.position_at(0)  # Parameter 0 = Start
            else:
                # Fallback: Vertex-basiert
                vertices = first_edge.vertices() if hasattr(first_edge, 'vertices') else []
                if vertices:
                    path_start = vertices[0].center() if hasattr(vertices[0], 'center') else Vector(0, 0, 0)
                else:
                    logger.warning("Sweep: Konnte Pfad-Startpunkt nicht ermitteln")
                    return profile_face

            # Profil-Zentrum ermitteln
            profile_center = profile_face.center() if hasattr(profile_face, 'center') else None
            if profile_center is None:
                # Fallback: Aus profile_data
                profile_data = feature.profile_data
                origin = profile_data.get('plane_origin', (0, 0, 0))
                profile_center = Vector(*origin)

            # Translation berechnen
            if isinstance(path_start, tuple):
                path_start = Vector(*path_start)

            translation = path_start - profile_center

            # Kleine Verschiebungen ignorieren (bereits am richtigen Ort)
            if translation.length < 0.1:  # < 0.1mm
                logger.debug("Sweep: Profil bereits am Pfad-Start")
                return profile_face

            logger.info(f"Sweep: Verschiebe Profil um {translation.length:.1f}mm zum Pfad-Start")

            # Profil verschieben
            moved_face = profile_face.move(Location(translation))

            return moved_face

        except Exception as e:
            logger.warning(f"Sweep: Profil-Verschiebung fehlgeschlagen: {e}, verwende Original")
            return profile_face

    def _is_curved_path(self, path_wire) -> bool:
        """
        Analysiert ob der Pfad gekrÃ¼mmt ist (nicht gerade).

        FÃ¼r OCP-First Sweep: Einfache Pfade kÃ¶nnen MakePipe verwenden,
        gekrÃ¼mmte Pfade benÃ¶tigen MakePipeShell.

        Args:
            path_wire: Build123d Wire

        Returns:
            True wenn gekrÃ¼mmt, False wenn gerade Linie
        """
        try:
            edges = list(path_wire.edges()) if hasattr(path_wire, 'edges') else []
            if len(edges) == 0:
                return False
            if len(edges) == 1:
                # Einzelne Edge prÃ¼fen
                edge = edges[0]
                # Gerade Linie hat gleiche Tangentenrichtung an Start/Ende
                try:
                    start_tangent = edge.tangent_at(0) if hasattr(edge, 'tangent_at') else None
                    end_tangent = edge.tangent_at(1) if hasattr(edge, 'tangent_at') else None
                    if start_tangent and end_tangent:
                        # Winkel zwischen Tangenten
                        dot = (start_tangent.X * end_tangent.X +
                                start_tangent.Y * end_tangent.Y +
                                start_tangent.Z * end_tangent.Z)
                        mag1 = (start_tangent.X**2 + start_tangent.Y**2 + start_tangent.Z**2)**0.5
                        mag2 = (end_tangent.X**2 + end_tangent.Y**2 + end_tangent.Z**2)**0.5
                        if mag1 > 0 and mag2 > 0:
                            cos_angle = dot / (mag1 * mag2)
                            # Parallel wenn cos ~ 1
                            return abs(cos_angle - 1.0) > 0.01
                except Exception:
                    pass
                # Kurven-Typ prÃ¼fen
                edge_type = edge.geom_type() if hasattr(edge, 'geom_type') else ''
                return edge_type not in ('LINE', 'FORWARD')
            # Multiple Edges: PrÃ¼fe ob alle in einer geraden Linie liegen
            vertices = []
            for edge in edges:
                verts = list(edge.vertices()) if hasattr(edge, 'vertices') else []
                vertices.extend([v.center() if hasattr(v, 'center') else v for v in verts])
            if len(vertices) < 3:
                return False
            # PrÃ¼fe ob alle Punkte kolinear sind
            v0 = vertices[0]
            v1 = vertices[-1]
            direction = v1 - v0
            dir_length = (direction.X**2 + direction.Y**2 + direction.Z**2)**0.5
            if dir_length < 1e-6:
                return False
            for vi in vertices[1:-1]:
                # Kreuzprodukt sollte Null sein fÃ¼r kolineare Punkte
                vi_v0 = vi - v0
                cross_x = direction.Y * vi_v0.Z - direction.Z * vi_v0.Y
                cross_y = direction.Z * vi_v0.X - direction.X * vi_v0.Z
                cross_z = direction.X * vi_v0.Y - direction.Y * vi_v0.X
                cross_mag = (cross_x**2 + cross_y**2 + cross_z**2)**0.5
                if cross_mag > 0.1:  # > 0.1mm Abweichung = gekrÃ¼mmt
                    return True
            return False
        except Exception as e:
            logger.debug(f"_is_curved_path Analyse fehlgeschlagen: {e}, assume curved")
            return True  # Conservative: Bei Fehler MakePipeShell verwenden

    def _compute_shell(self, feature: 'ShellFeature', current_solid):
        """
        OCP-First Shell mit direktem OpenCASCADE BRepOffsetAPI_MakeThickSolid.

        UnterstÃ¼tzt:
        - Shell mit Ã–ffnungen (faces_to_remove)
        - Geschlossener HohlkÃ¶rper (leere faces_to_remove)
        """
        if current_solid is None:
            raise ValueError("Shell benÃ¶tigt einen existierenden KÃ¶rper")

        # Ã–ffnungs-Faces auflÃ¶sen (TNP v4.0)
        opening_faces = self._resolve_faces_for_shell(current_solid, feature.opening_face_selectors, feature)
        has_opening_refs = bool(
            feature.face_shape_ids
            or feature.face_indices
            or feature.opening_face_selectors
        )
        if has_opening_refs and not opening_faces:
            raise ValueError(
                "Shell: Ã–ffnungs-Faces konnten via TNP v4.0 nicht aufgelÃ¶st werden "
                "(ShapeID/face_indices). Kein Geometric-Fallback."
            )

        logger.debug(f"Shell mit Dicke={feature.thickness}mm, {len(opening_faces)} Ã–ffnungen")

        # OCP-First Shell
        from OCP.BRepOffsetAPI import BRepOffsetAPI_MakeThickSolid
        from OCP.TopTools import TopTools_ListOfShape
        from config.tolerances import Tolerances
        from build123d import Solid

        shape = current_solid.wrapped if hasattr(current_solid, 'wrapped') else current_solid

        # Liste der zu entfernenden Faces
        faces_to_remove = TopTools_ListOfShape()
        for face in opening_faces:
            face_shape = face.wrapped if hasattr(face, 'wrapped') else face
            faces_to_remove.Append(face_shape)

        # Shell erstellen (MakeThickSolidByJoin)
        shell_op = BRepOffsetAPI_MakeThickSolid()
        shell_op.MakeThickSolidByJoin(
            shape,
            faces_to_remove,  # Leer = geschlossener HohlkÃ¶rper
            -feature.thickness,  # Negativ fÃ¼r nach innen
            Tolerances.SHELL_TOLERANCE
        )
        shell_op.Build()

        if not shell_op.IsDone():
            raise ValueError(f"Shell OCP-Operation fehlgeschlagen: IsDone()=False")

        result_shape = shell_op.Shape()
        result_shape = self._fix_shape_ocp(result_shape)

        # Zu Build123d Solid wrappen
        result = Solid(result_shape)

        if not result.is_valid():
            raise ValueError("Shell erzeugte keinen gÃ¼ltigen Solid")

        # TNP-Registration wenn naming_service verfÃ¼gbar
        if self._document and hasattr(self._document, '_shape_naming_service'):
            try:
                naming_service = self._document._shape_naming_service
                feature_id = getattr(feature, 'id', None) or str(id(feature))

                # Alle Faces registrieren
                from modeling.tnp_system import ShapeType
                from OCP.TopExp import TopExp_Explorer
                from OCP.TopAbs import TopAbs_FACE

                explorer = TopExp_Explorer(result_shape, TopAbs_FACE)
                face_idx = 0
                while explorer.More():
                    face_shape = explorer.Current()
                    naming_service.register_shape(
                        ocp_shape=face_shape,
                        shape_type=ShapeType.FACE,
                        feature_id=feature_id,
                        local_index=face_idx
                    )
                    face_idx += 1
                    explorer.Next()

                # Alle Edges registrieren
                naming_service.register_solid_edges(result, feature_id)

                if is_enabled("tnp_debug_logging"):
                    logger.success(f"Shell TNP: {face_idx} Faces registriert")

            except Exception as e:
                logger.error(f"Shell TNP Registration fehlgeschlagen: {e}")

        logger.debug(f"OCP Shell erfolgreich ({len(opening_faces)} Ã–ffnungen)")
        return result

    def _unify_same_domain(self, shape, context: str = ""):
        """
        Vereinigt zusammenhÃ¤ngende FlÃ¤chen mit gleicher Geometrie.

        Besonders wichtig fÃ¼r:
        - Planare FlÃ¤chen die durch Boolean-Ops entstanden sind
        - Zylindrische FlÃ¤chen die durch Extrusion entstanden sind

        Args:
            shape: OCP TopoDS_Shape
            context: Beschreibung fÃ¼r Logging

        Returns:
            Vereinigtes Shape (oder Original wenn Vereinigung fehlschlÃ¤gt)
        """
        try:
            from OCP.ShapeUpgrade import ShapeUpgrade_UnifySameDomain
            from OCP.TopExp import TopExp_Explorer
            from OCP.TopAbs import TopAbs_FACE

            # ZÃ¤hle Faces vorher
            face_count_before = 0
            exp = TopExp_Explorer(shape, TopAbs_FACE)
            while exp.More():
                face_count_before += 1
                exp.Next()

            # UnifySameDomain mit erhÃ¶hten Toleranzen fÃ¼r Zylinder
            upgrader = ShapeUpgrade_UnifySameDomain(shape, True, True, True)
            upgrader.SetLinearTolerance(0.1)   # 0.1mm - groÃŸzÃ¼giger fÃ¼r Zylinder-Segmente
            upgrader.SetAngularTolerance(0.1)  # ~5.7Â° - erlaubt Merge von Zylinder-Facetten
            upgrader.Build()
            unified = upgrader.Shape()

            if unified and not unified.IsNull():
                # ZÃ¤hle Faces nachher
                face_count_after = 0
                exp = TopExp_Explorer(unified, TopAbs_FACE)
                while exp.More():
                    face_count_after += 1
                    exp.Next()

                if face_count_before != face_count_after:
                    logger.debug(f"UnifySameDomain ({context}): {face_count_before} â†’ {face_count_after} Faces")
                return unified

            return shape
        except Exception as e:
            logger.trace(f"UnifySameDomain ({context}): {e}")
            return shape

    def _compute_nsided_patch(self, feature: 'NSidedPatchFeature', current_solid):
        """
        N-Sided Patch: Boundary-Edges finden und mit BRepFill_Filling fÃ¼llen.
        Das Ergebnis wird per Sewing an den bestehenden Solid angefÃ¼gt.
        """
        if current_solid is None:
            raise ValueError("N-Sided Patch benÃ¶tigt einen existierenden KÃ¶rper")

        all_edges = current_solid.edges() if hasattr(current_solid, 'edges') else []
        if not all_edges:
            raise ValueError("Solid hat keine Kanten")
        if not feature.edge_shape_ids and not feature.edge_indices and not feature.geometric_selectors:
            raise ValueError("N-Sided Patch benÃ¶tigt mindestens 3 Kanten-Referenzen")

        resolved_edges = []

        def _is_same_edge(edge_a, edge_b) -> bool:
            try:
                wa = edge_a.wrapped if hasattr(edge_a, 'wrapped') else edge_a
                wb = edge_b.wrapped if hasattr(edge_b, 'wrapped') else edge_b
                return wa.IsSame(wb)
            except Exception:
                return edge_a is edge_b

        def _append_unique(edge_obj) -> None:
            if edge_obj is None:
                return
            for existing in resolved_edges:
                if _is_same_edge(existing, edge_obj):
                    return
            resolved_edges.append(edge_obj)

        # TNP v4.0: Zentraler Resolver (ShapeID / edge_indices / strict Selector-Policy)
        tnp_edges = self._resolve_edges_tnp(current_solid, feature)
        for edge in tnp_edges:
            _append_unique(edge)
        if is_enabled("tnp_debug_logging"):
            logger.debug(
                f"N-Sided Patch: {len(tnp_edges)} Edges via zentralem TNP-Resolver aufgelÃ¶st"
            )

        # FÃ¼r zukÃ¼nftige Rebuilds ShapeIDs + GeometricSelectors + Edge-Indizes persistieren
        if resolved_edges:
            try:
                resolved_indices = []
                for edge in resolved_edges:
                    for edge_idx, candidate in enumerate(all_edges):
                        if _is_same_edge(candidate, edge):
                            resolved_indices.append(edge_idx)
                            break
                if resolved_indices:
                    feature.edge_indices = resolved_indices
            except Exception as e:
                logger.debug(f"N-Sided Patch: Persistieren von Edge-Indizes fehlgeschlagen: {e}")

        if resolved_edges and self._document and hasattr(self._document, '_shape_naming_service'):
            try:
                from modeling.geometric_selector import GeometricEdgeSelector
                service = self._document._shape_naming_service

                new_shape_ids = []
                new_geo_selectors = []
                for idx, edge in enumerate(resolved_edges):
                    new_geo_selectors.append(GeometricEdgeSelector.from_edge(edge).to_dict())
                    shape_id = service.find_shape_id_by_edge(edge)
                    if shape_id is None and hasattr(edge, 'wrapped'):
                        ec = edge.center()
                        edge_len = edge.length if hasattr(edge, 'length') else 0.0
                        shape_id = service.register_shape(
                            ocp_shape=edge.wrapped,
                            shape_type=ShapeType.EDGE,
                            feature_id=feature.id,
                            local_index=idx,
                            geometry_data=(ec.X, ec.Y, ec.Z, edge_len)
                        )
                    if shape_id is not None:
                        new_shape_ids.append(shape_id)

                if new_shape_ids:
                    feature.edge_shape_ids = new_shape_ids
                if new_geo_selectors:
                    feature.geometric_selectors = new_geo_selectors
            except Exception as e:
                logger.debug(f"N-Sided Patch: Persistieren von ShapeIDs fehlgeschlagen: {e}")

        if len(resolved_edges) < 3:
            expected = (
                len(feature.edge_shape_ids or [])
                or len(feature.edge_indices or [])
                or len(feature.geometric_selectors or [])
            )
            logger.warning(f"Nur {len(resolved_edges)} von {expected} Kanten aufgelÃ¶st")
            raise ValueError(f"Nur {len(resolved_edges)} von {expected} Kanten aufgelÃ¶st")

        logger.debug(f"N-Sided Patch: {len(resolved_edges)} Kanten, Grad={feature.degree}")

        from modeling.nsided_patch import NSidedPatch

        # Patch erstellen
        patch_face = NSidedPatch.fill_edges(
            resolved_edges,
            tangent_faces=NSidedPatch._find_adjacent_faces(
                current_solid, resolved_edges
            ) if feature.tangent else None,
            degree=feature.degree,
        )

        if patch_face is None:
            raise RuntimeError("N-Sided Patch: BRepFill_Filling fehlgeschlagen")

        # Patch-Face zum Solid hinzufÃ¼gen
        # Methode: BRepBuilderAPI_MakeSolid aus allen Faces (original + patch)
        try:
            from OCP.BRepBuilderAPI import BRepBuilderAPI_Sewing, BRepBuilderAPI_MakeSolid
            from OCP.TopExp import TopExp_Explorer
            from OCP.TopAbs import TopAbs_SHELL, TopAbs_FACE
            from OCP.TopoDS import TopoDS
            from OCP.BRep import BRep_Builder
            from OCP.TopoDS import TopoDS_Shell, TopoDS_Compound
            from build123d import Solid

            shape = current_solid.wrapped if hasattr(current_solid, 'wrapped') else current_solid
            patch_shape = patch_face.wrapped if hasattr(patch_face, 'wrapped') else patch_face

            # Sewing mit grÃ¶ÃŸerer Toleranz fÃ¼r bessere Verbindung
            sewing = BRepBuilderAPI_Sewing(0.1)  # 0.1mm Toleranz
            sewing.SetNonManifoldMode(False)  # Manifold-Ergebnis erzwingen

            # Alle Faces des Original-Solids hinzufÃ¼gen
            face_explorer = TopExp_Explorer(shape, TopAbs_FACE)
            n_faces = 0
            while face_explorer.More():
                sewing.Add(face_explorer.Current())
                n_faces += 1
                face_explorer.Next()

            # Patch-Face hinzufÃ¼gen
            sewing.Add(patch_shape)
            logger.debug(f"N-Sided Patch: Sewing {n_faces} Original-Faces + 1 Patch-Face")

            sewing.Perform()
            sewn = sewing.SewedShape()

            # PrÃ¼fe Sewing-Ergebnis
            n_sewn_faces = 0
            face_exp = TopExp_Explorer(sewn, TopAbs_FACE)
            while face_exp.More():
                n_sewn_faces += 1
                face_exp.Next()
            logger.debug(f"N-Sided Patch: Sewing-Ergebnis hat {n_sewn_faces} Faces (erwartet: {n_faces + 1})")

            # Versuche Solid zu bauen
            shell_explorer = TopExp_Explorer(sewn, TopAbs_SHELL)
            if shell_explorer.More():
                shell = TopoDS.Shell_s(shell_explorer.Current())

                # PrÃ¼fe ob Shell geschlossen ist
                from OCP.BRep import BRep_Tool
                from OCP.ShapeAnalysis import ShapeAnalysis_Shell
                analyzer = ShapeAnalysis_Shell()
                analyzer.LoadShells(shell)
                is_closed = not analyzer.HasFreeEdges()
                logger.debug(f"N-Sided Patch: Shell geschlossen = {is_closed}")

                maker = BRepBuilderAPI_MakeSolid(shell)
                maker.Build()

                if maker.IsDone():
                    result = Solid(maker.Shape())
                    result_faces = len(result.faces()) if hasattr(result, 'faces') else 0
                    if hasattr(result, 'is_valid') and result.is_valid():
                        logger.debug(f"N-Sided Patch: Loch geschlossen! ({result_faces} Faces)")
                        return result
                    else:
                        logger.warning(f"N-Sided Patch: Solid mit {result_faces} Faces ungÃ¼ltig, versuche ShapeFix...")
                        # ShapeFix versuchen
                        try:
                            from OCP.ShapeFix import ShapeFix_Solid
                            fixer = ShapeFix_Solid(maker.Shape())
                            fixer.Perform()
                            if fixer.Shape() and not fixer.Shape().IsNull():
                                fixed = Solid(fixer.Shape())
                                if hasattr(fixed, 'is_valid') and fixed.is_valid():
                                    logger.debug(f"N-Sided Patch: ShapeFix erfolgreich")
                                    return fixed
                        except Exception as fix_err:
                            logger.debug(f"ShapeFix fehlgeschlagen: {fix_err}")
            else:
                logger.warning("N-Sided Patch: Keine Shell im Sewing-Ergebnis")

            # Fallback: Versuche grÃ¶ÃŸere Toleranz
            logger.warning("N-Sided Patch: Erster Sewing-Versuch fehlgeschlagen, versuche mit hÃ¶herer Toleranz...")
            sewing2 = BRepBuilderAPI_Sewing(1.0)  # 1mm Toleranz
            sewing2.SetNonManifoldMode(False)

            face_explorer2 = TopExp_Explorer(shape, TopAbs_FACE)
            while face_explorer2.More():
                sewing2.Add(face_explorer2.Current())
                face_explorer2.Next()
            sewing2.Add(patch_shape)
            sewing2.Perform()
            sewn2 = sewing2.SewedShape()

            shell_exp2 = TopExp_Explorer(sewn2, TopAbs_SHELL)
            if shell_exp2.More():
                shell2 = TopoDS.Shell_s(shell_exp2.Current())
                maker2 = BRepBuilderAPI_MakeSolid(shell2)
                maker2.Build()
                if maker2.IsDone():
                    result2 = Solid(maker2.Shape())
                    if hasattr(result2, 'is_valid') and result2.is_valid():
                        logger.debug(f"N-Sided Patch: Loch geschlossen mit hÃ¶herer Toleranz!")
                        return result2

            # Letzter Fallback
            logger.warning("N-Sided Patch: Sewing komplett fehlgeschlagen")
            from build123d import Shape
            return Shape(sewn)

        except Exception as e:
            logger.error(f"N-Sided Patch Sewing fehlgeschlagen: {e}")
            raise

    def _compute_hollow(self, feature: 'HollowFeature', current_solid):
        """
        AushÃ¶hlen mit optionalem Drain Hole.
        1. Shell (geschlossen) via _compute_shell-Logik
        2. Optional: Boolean Cut mit Zylinder fÃ¼r Drain Hole
        """
        if current_solid is None:
            raise ValueError("Hollow benÃ¶tigt einen existierenden KÃ¶rper")

        # TNP v4.0: Face-Referenzen vor der Shell-AusfÃ¼hrung aktualisieren
        self._update_face_selectors_for_feature(feature, current_solid)

        # Step 1: Create closed shell (reuse shell logic)
        # TNP v4.0: Leite opening_face_shape_ids und selectors durch
        shell_feat = ShellFeature(
            thickness=feature.wall_thickness,
            opening_face_selectors=feature.opening_face_selectors if feature.opening_face_selectors else []
        )
        # Ãœbertrage Opening-ShapeIDs auf ShellFeature.face_shape_ids (TNP v4.0)
        if feature.opening_face_shape_ids:
            shell_feat.face_shape_ids = list(feature.opening_face_shape_ids)
        if feature.opening_face_indices:
            shell_feat.face_indices = list(feature.opening_face_indices)

        hollowed = self._compute_shell(shell_feat, current_solid)
        if hollowed is None:
            raise ValueError("Shell-Erzeugung fehlgeschlagen")

        # Step 2: Drain hole (optional)
        if feature.drain_hole and feature.drain_diameter > 0:
            try:
                from build123d import Cylinder, Location, Vector, Solid
                import math

                pos = feature.drain_position
                d = feature.drain_direction
                radius = feature.drain_diameter / 2.0

                # Hole must be long enough to pierce through the wall
                # Use bounding box diagonal as safe length
                bb = hollowed.bounding_box()
                safe_length = 2.0 * max(bb.size.X, bb.size.Y, bb.size.Z)

                cyl = Cylinder(radius, safe_length)

                # Align cylinder along drain direction
                z_axis = Vector(0, 0, 1)
                drain_vec = Vector(*d)
                if drain_vec.length > 1e-9:
                    drain_vec = drain_vec.normalized()
                else:
                    drain_vec = Vector(0, 0, -1)

                # Position at drain point, centered along direction
                from build123d import Pos, Rot
                center = Vector(*pos) - drain_vec * (safe_length / 2)

                # Compute rotation from Z to drain direction
                cross = z_axis.cross(drain_vec)
                dot = z_axis.dot(drain_vec)
                if cross.length > 1e-9:
                    angle = math.degrees(math.acos(max(-1, min(1, dot))))
                    axis = cross.normalized()
                    from build123d import Axis
                    cyl = cyl.rotate(Axis.Z, 0)  # identity
                    # Use Location with rotation
                    from OCP.gp import gp_Ax1, gp_Pnt, gp_Dir, gp_Trsf
                    trsf = gp_Trsf()
                    trsf.SetRotation(
                        gp_Ax1(gp_Pnt(0, 0, 0), gp_Dir(axis.X, axis.Y, axis.Z)),
                        math.radians(angle)
                    )
                    trsf.SetTranslationPart(
                        gp_Pnt(center.X, center.Y, center.Z).XYZ()
                                            )
                    from OCP.BRepBuilderAPI import BRepBuilderAPI_Transform
                    builder = BRepBuilderAPI_Transform(cyl.wrapped, trsf, True)
                    builder.Build()
                    cyl = Solid(builder.Shape())
                elif dot < 0:
                    # Anti-parallel: rotate 180Â° around X
                    from build123d import Axis
                    cyl = cyl.rotate(Axis.X, 180)
                    cyl = cyl.move(Location((center.X, center.Y, center.Z)))
                else:
                    cyl = cyl.move(Location((center.X, center.Y, center.Z)))

                result = hollowed - cyl
                if result and hasattr(result, 'is_valid') and result.is_valid():
                    logger.debug(f"Hollow mit Drain Hole (âŒ€{feature.drain_diameter}mm) erfolgreich")
                    return result
                else:
                    logger.warning("Drain Hole Boolean fehlgeschlagen, verwende Shell ohne Drain")
                    return hollowed

            except Exception as e:
                logger.warning(f"Drain Hole fehlgeschlagen: {e}, verwende Shell ohne Drain")
                return hollowed

        logger.debug(f"Hollow (WandstÃ¤rke {feature.wall_thickness}mm) erfolgreich")
        return hollowed

    def _compute_hole(self, feature: 'HoleFeature', current_solid):
        """
        Erstellt eine Bohrung.

        Methoden (in PrioritÃ¤t):
        1. BRepFeat_MakeCylindricalHole (fÃ¼r simple holes - saubere Topologie)
        2. Boolean Cut mit Zylinder (fÃ¼r counterbore, countersink, oder Fallback)
        """
        from build123d import Cylinder, Vector, Align
        import math

        if current_solid is None:
            raise ValueError("Hole: Kein gÃ¼ltiges Eingabe-Solid vorhanden")
        if feature.diameter <= 0:
            raise ValueError(f"Hole: UngÃ¼ltiger Durchmesser {feature.diameter}mm (muss > 0 sein)")
        if feature.depth < 0:
            raise ValueError(f"Hole: UngÃ¼ltige Tiefe {feature.depth}mm (muss >= 0 sein)")
        if feature.hole_type not in {"simple", "counterbore", "countersink"}:
            raise ValueError(f"Hole: Unbekannter hole_type '{feature.hole_type}'")
        if feature.hole_type == "counterbore":
            if feature.counterbore_diameter <= feature.diameter:
                raise ValueError(
                    f"Hole: Counterbore-Durchmesser {feature.counterbore_diameter}mm "
                    f"muss grÃ¶ÃŸer als Bohrungsdurchmesser {feature.diameter}mm sein"
                )
            if feature.counterbore_depth <= 0:
                raise ValueError(f"Hole: Counterbore-Tiefe {feature.counterbore_depth}mm muss > 0 sein")
        if feature.hole_type == "countersink":
            if feature.countersink_angle <= 0 or feature.countersink_angle >= 179:
                raise ValueError(
                    f"Hole: Countersink-Winkel {feature.countersink_angle}Â° ist ungÃ¼ltig "
                    "(erwartet: 0 < Winkel < 179)"
                )

        # TNP v4.0: Face-Referenzen auflÃ¶sen/aktualisieren
        target_faces = self._resolve_feature_faces(feature, current_solid)
        has_face_refs = bool(feature.face_shape_ids or feature.face_indices or feature.face_selectors)
        if has_face_refs and not target_faces:
            raise ValueError(
                "Hole: Ziel-Face konnte via TNP v4.0 nicht aufgelÃ¶st werden "
                f"(ShapeIDs={len(feature.face_shape_ids or [])}, "
                f"Indices={len(feature.face_indices or [])}, "
                f"Selectors={len(feature.face_selectors or [])})"
            )

        pos = Vector(*feature.position)
        d = Vector(*feature.direction)
        if target_faces:
            # Falls Richtung ungÃ¼ltig ist, aus Face-Normale ableiten
            try:
                face_center = target_faces[0].center()
                face_normal = target_faces[0].normal_at(face_center)
                if d.length < 1e-9:
                    d = Vector(-face_normal.X, -face_normal.Y, -face_normal.Z)
                if pos.length < 1e-9:
                    pos = Vector(face_center.X, face_center.Y, face_center.Z)
            except Exception:
                pass

        if d.length < 1e-9:
            raise ValueError("Hole: UngÃ¼ltige Bohrungsrichtung (Nullvektor)")

        d = d.normalized()
        radius = feature.diameter / 2.0

        # Tiefe: 0 = through all (verwende grosse Tiefe)
        depth = feature.depth if feature.depth > 0 else 1000.0

        logger.debug(f"Hole: type={feature.hole_type}, D={feature.diameter}mm, depth={depth}mm at {pos}")

        # === METHODE 1: BRepFeat_MakeCylindricalHole (nur fÃ¼r simple holes) ===
        brepfeat_reason = ""
        if feature.hole_type == "simple":
            try:
                from modeling.brepfeat_operations import brepfeat_cylindrical_hole

                result = brepfeat_cylindrical_hole(
                    base_solid=current_solid,
                    position=(pos.X, pos.Y, pos.Z),
                    direction=(d.X, d.Y, d.Z),
                    diameter=feature.diameter,
                    depth=feature.depth  # 0 = through all
                )

                if result is not None:
                    logger.debug(f"Hole via BRepFeat: D={feature.diameter}mm")
                    return result
                else:
                    brepfeat_reason = "BRepFeat_MakeCylindricalHole lieferte kein Resultat"
                    logger.debug("BRepFeat_MakeCylindricalHole fehlgeschlagen, Fallback auf Boolean")
            except Exception as e:
                brepfeat_reason = f"BRepFeat Fehler: {e}"
                logger.debug(f"BRepFeat Hole: {e}, Fallback auf Boolean")

        # === METHODE 2: Boolean Cut (fÃ¼r counterbore, countersink, oder Fallback) ===

        # Hauptbohrung als Zylinder erstellen
        hole_cyl = Cylinder(radius, depth,
                            align=(Align.CENTER, Align.CENTER, Align.MIN))

        # Rotation: Standard-Zylinder zeigt in +Z, wir brauchen feature.direction
        from OCP.gp import gp_Trsf, gp_Ax1, gp_Pnt, gp_Dir, gp_Vec
        from OCP.BRepBuilderAPI import BRepBuilderAPI_Transform

        # Zylinder in Position bringen
        hole_shape = self._position_cylinder(hole_cyl, pos, d, depth)
        if hole_shape is None:
            raise ValueError("Hole-Zylinder konnte nicht positioniert werden")

        # Counterbore: zusaetzlicher breiterer Zylinder oben
        if feature.hole_type == "counterbore":
            cb_radius = feature.counterbore_diameter / 2.0
            cb_depth = feature.counterbore_depth
            cb_cyl = Cylinder(cb_radius, cb_depth,
                              align=(Align.CENTER, Align.CENTER, Align.MIN))
            cb_shape = self._position_cylinder(cb_cyl, pos, d, cb_depth)
            if cb_shape is None:
                raise ValueError("Hole: Counterbore-Geometrie konnte nicht positioniert werden")
            hole_shape = hole_shape.fuse(cb_shape)

        # Countersink: Kegel oben
        elif feature.hole_type == "countersink":
            cs_angle_rad = math.radians(feature.countersink_angle / 2.0)
            cs_depth = radius / math.tan(cs_angle_rad) if cs_angle_rad > 0 else 2.0
            from build123d import Cone
            cs_cone = Cone(feature.diameter, 0.01, cs_depth,
                           align=(Align.CENTER, Align.CENTER, Align.MIN))
            cs_shape = self._position_cylinder(cs_cone, pos, d, cs_depth)
            if cs_shape is None:
                raise ValueError("Hole: Countersink-Geometrie konnte nicht positioniert werden")
            hole_shape = hole_shape.fuse(cs_shape)

        # Boolean Cut: Bohrung vom Koerper abziehen via BooleanEngineV4 (TNP-safe)
        # Zuerst Tool-Shapes registrieren (damit sie ShapeIDs haben)
        if self._document and hasattr(self._document, '_shape_naming_service'):
            # Wir registrieren das Tool als temporÃ¤res Feature oder unter der Hole-ID
            # Da das Hole-Feature das Tool "besitzt", ist es okay, die Faces des Tools
            # unter der Feature-ID zu registrieren.
            self._register_base_feature_shapes(feature, hole_shape)

        # Boolean ausfÃ¼hren
        bool_result = BooleanEngineV4.execute_boolean_on_shapes(
            current_solid, hole_shape, "Cut"
        )

        if bool_result.is_success:
            result = bool_result.value
            self._register_boolean_history(bool_result, feature, operation_name="Hole_Cut")
            logger.debug(f"Hole {feature.hole_type} D={feature.diameter}mm erfolgreich (BooleanV4)")
            return result
        else:
            logger.warning(f"Hole Boolean fehlgeschlagen: {bool_result.message}")
            if brepfeat_reason:
                 raise ValueError(f"Hole fehlgeschlagen. BRepFeat: {brepfeat_reason}. Boolean: {bool_result.message}")
            raise ValueError(f"Hole Boolean fehlgeschlagen: {bool_result.message}")

    def _position_cylinder(self, cyl_solid, position, direction, depth):
        """Positioniert einen Zylinder an position entlang direction."""
        try:
            from build123d import Vector, Location
            import numpy as np

            # Support both tuples and Build123d Vectors
            if hasattr(direction, 'X'):
                d = np.array([direction.X, direction.Y, direction.Z], dtype=float)
            else:
                d = np.array([direction[0], direction[1], direction[2]], dtype=float)
            d_norm = d / (np.linalg.norm(d) + 1e-12)

            # Start etwas vor der Flaeche (damit der Cut sicher durchgeht)
            if hasattr(position, 'X'):
                pos = np.array([position.X, position.Y, position.Z])
            else:
                pos = np.array([position[0], position[1], position[2]])
            start = pos - d_norm * 0.5

            # Rotation berechnen: Z-Achse -> direction
            z_axis = np.array([0, 0, 1.0])
            if abs(np.dot(z_axis, d_norm)) > 0.999:
                # Parallel zu Z - keine Rotation noetig
                rotated = cyl_solid
            else:
                rot_axis = np.cross(z_axis, d_norm)
                rot_axis = rot_axis / (np.linalg.norm(rot_axis) + 1e-12)
                angle = np.arccos(np.clip(np.dot(z_axis, d_norm), -1, 1))

                from OCP.gp import gp_Trsf, gp_Ax1, gp_Pnt, gp_Dir
                from OCP.BRepBuilderAPI import BRepBuilderAPI_Transform
                import math

                trsf = gp_Trsf()
                ax = gp_Ax1(gp_Pnt(0, 0, 0), gp_Dir(rot_axis[0], rot_axis[1], rot_axis[2]))
                trsf.SetRotation(ax, angle)

                shape = cyl_solid.wrapped if hasattr(cyl_solid, 'wrapped') else cyl_solid
                builder = BRepBuilderAPI_Transform(shape, trsf, True)
                builder.Build()
                from build123d import Solid
                rotated = Solid(builder.Shape())

            # Translation
            from OCP.gp import gp_Trsf, gp_Vec as gp_V
            from OCP.BRepBuilderAPI import BRepBuilderAPI_Transform
            trsf2 = gp_Trsf()
            trsf2.SetTranslation(gp_V(start[0], start[1], start[2]))

            shape2 = rotated.wrapped if hasattr(rotated, 'wrapped') else rotated
            builder2 = BRepBuilderAPI_Transform(shape2, trsf2, True)
            builder2.Build()
            from build123d import Solid
            return Solid(builder2.Shape())

        except Exception as e:
            logger.error(f"Zylinder-Positionierung fehlgeschlagen: {e}")
            return None

    def _compute_draft(self, feature: 'DraftFeature', current_solid):
        """
        Wendet Draft/Taper auf selektierte Flaechen an.
        Verwendet OCP BRepOffsetAPI_DraftAngle.
        TNP v4.0: Face-Selektion erfolgt Ã¼ber face_shape_ids (ShapeNamingService).
        """
        import math
        from OCP.BRepOffsetAPI import BRepOffsetAPI_DraftAngle
        from OCP.gp import gp_Dir, gp_Pln, gp_Pnt
        from OCP.TopAbs import TopAbs_FACE
        from OCP.TopExp import TopExp_Explorer
        from OCP.TopoDS import TopoDS

        shape = current_solid.wrapped if hasattr(current_solid, 'wrapped') else current_solid

        if current_solid is None:
            raise ValueError("Draft: Kein gÃ¼ltiges Eingabe-Solid vorhanden")
        if abs(feature.draft_angle) >= 89.9:
            raise ValueError(
                f"Draft: UngÃ¼ltiger Winkel {feature.draft_angle}Â°. "
                "Erwartet |Winkel| < 89.9Â°"
            )
        if len(feature.pull_direction) < 3:
            raise ValueError("Draft: Pull-Richtung ist unvollstÃ¤ndig")
        px, py, pz = feature.pull_direction[0], feature.pull_direction[1], feature.pull_direction[2]
        if (px * px + py * py + pz * pz) <= 1e-12:
            raise ValueError("Draft: UngÃ¼ltige Pull-Richtung (Nullvektor)")

        pull_dir = gp_Dir(px, py, pz)
        angle_rad = math.radians(feature.draft_angle)

        # Neutrale Ebene (Basis der Entformung)
        neutral_plane = gp_Pln(gp_Pnt(0, 0, 0), pull_dir)

        target_faces = self._resolve_feature_faces(feature, current_solid)
        has_face_refs = bool(feature.face_shape_ids or feature.face_indices or feature.face_selectors)

        if has_face_refs and not target_faces:
            raise ValueError("Draft: Ziel-Faces konnten via TNP v4.0 nicht aufgelÃ¶st werden")

        draft_op = BRepOffsetAPI_DraftAngle(shape)
        face_count = 0
        add_errors = []

        if target_faces:
            for face_idx, target_face in enumerate(target_faces):
                try:
                    topo_face = target_face.wrapped if hasattr(target_face, 'wrapped') else target_face
                    draft_op.Add(TopoDS.Face_s(topo_face), pull_dir, angle_rad, neutral_plane)
                    face_count += 1
                except Exception as e:
                    add_errors.append(f"Face[{face_idx}] konnte nicht hinzugefÃ¼gt werden: {e}")
        else:
            # Kein explizites Face-Target -> alle Faces draften (Legacy-Verhalten)
            explorer = TopExp_Explorer(shape, TopAbs_FACE)
            all_face_idx = 0
            while explorer.More():
                face = TopoDS.Face_s(explorer.Current())
                try:
                    draft_op.Add(face, pull_dir, angle_rad, neutral_plane)
                    face_count += 1
                except Exception as e:
                    add_errors.append(f"Face[{all_face_idx}] konnte nicht hinzugefÃ¼gt werden: {e}")
                explorer.Next()
                all_face_idx += 1

        if face_count == 0:
            detail = add_errors[0] if add_errors else "kein kompatibles Ziel-Face gefunden"
            raise ValueError(f"Draft: Keine FlÃ¤chen konnten gedraftet werden ({detail})")

        draft_op.Build()
        if draft_op.IsDone():
            result_shape = draft_op.Shape()
            result_shape = self._fix_shape_ocp(result_shape)

            # TNP v4.0: History Tracking fÃ¼r Draft
            if self._document and hasattr(self._document, '_shape_naming_service'):
                try:
                    service = self._document._shape_naming_service
                    feature_id = getattr(feature, 'id', None) or str(id(feature))
                    
                    # History tracken (Faces modified/generated)
                    service.track_draft_operation(
                        feature_id=feature_id,
                        source_solid=shape,
                        result_solid=result_shape,
                        occt_history=draft_op,
                        angle=feature.draft_angle
                    )
                except Exception as e:
                    logger.warning(f"Draft TNP tracking fail: {e}")

            from build123d import Solid
            result = Solid(result_shape)
            logger.debug(f"Draft {feature.draft_angle}Â° auf {face_count} Flaechen erfolgreich")
            return result

        raise ValueError("Draft-Operation fehlgeschlagen")

    def _compute_split(self, feature: 'SplitFeature', current_solid):
        """
        Teilt einen Koerper entlang einer Ebene.

        TNP v4.0 / Multi-Body Architecture:
        - Berechnet BEIDE HÃ¤lften (above + below)
        - Gibt SplitResult zurÃ¼ck mit beiden Bodies
        - FÃ¼r legacy keep_side != "both": Gibt nur eine HÃ¤lfte als Solid zurÃ¼ck

        Returns:
            - SplitResult (wenn keep_side == "both")
            - Solid (wenn keep_side == "above" oder "below" - legacy)
        """
        from OCP.BRepAlgoAPI import BRepAlgoAPI_Section
        from OCP.gp import gp_Pln, gp_Pnt, gp_Dir
        from OCP.BRepPrimAPI import BRepPrimAPI_MakeHalfSpace
        from OCP.BRepAlgoAPI import BRepAlgoAPI_Cut
        from OCP.BRepBuilderAPI import BRepBuilderAPI_MakeFace
        import numpy as np

        shape = current_solid.wrapped if hasattr(current_solid, 'wrapped') else current_solid

        origin = gp_Pnt(*feature.plane_origin)
        normal = gp_Dir(*feature.plane_normal)
        plane = gp_Pln(origin, normal)

        logger.debug(f"Split: origin={feature.plane_origin}, normal={feature.plane_normal}, keep={feature.keep_side}")

        # === Phase 1: Grosse Ebene als Face erstellen ===
        face_builder = BRepBuilderAPI_MakeFace(plane, -1000, 1000, -1000, 1000)
        face_builder.Build()
        if not face_builder.IsDone():
            raise ValueError("Split-Ebene konnte nicht erstellt werden")

        split_face = face_builder.Face()

        # === Phase 2: Beide HalfSpaces erstellen ===
        n = np.array(feature.plane_normal, dtype=float)
        n = n / (np.linalg.norm(n) + 1e-12)

        # HalfSpace ABOVE (+normal Seite)
        ref_pt_above = np.array(feature.plane_origin) + n * 100.0
        half_space_above = BRepPrimAPI_MakeHalfSpace(split_face, gp_Pnt(*ref_pt_above))
        half_solid_above = half_space_above.Solid()

        # HalfSpace BELOW (-normal Seite)
        ref_pt_below = np.array(feature.plane_origin) - n * 100.0
        half_space_below = BRepPrimAPI_MakeHalfSpace(split_face, gp_Pnt(*ref_pt_below))
        half_solid_below = half_space_below.Solid()

        # === Phase 3: Beide Cuts durchfÃ¼hren ===
        cut_above = BRepAlgoAPI_Cut(shape, half_solid_below)  # Cut away below â†’ keep above
        cut_below = BRepAlgoAPI_Cut(shape, half_solid_above)  # Cut away above â†’ keep below

        cut_above.Build()
        cut_below.Build()

        if not (cut_above.IsDone() and cut_below.IsDone()):
            raise ValueError("Split-Operation fehlgeschlagen - einer der Cuts konnte nicht durchgefÃ¼hrt werden")

        # === Phase 4: Beide Solids erstellen ===
        result_above_shape = self._fix_shape_ocp(cut_above.Shape())
        result_below_shape = self._fix_shape_ocp(cut_below.Shape())

        from build123d import Solid
        body_above = Solid(result_above_shape)
        body_below = Solid(result_below_shape)

        # === Phase 5: Legacy vs Multi-Body Mode ===
        if feature.keep_side == "both":
            # TNP v4.0 Multi-Body Mode
            result = SplitResult(
                body_above=body_above,
                body_below=body_below,
                split_plane={
                    "origin": feature.plane_origin,
                    "normal": feature.plane_normal
                }
            )
            logger.debug(f"Split (both) erfolgreich â†’ 2 Bodies erstellt")
            return result
        elif feature.keep_side == "above":
            # Legacy: Nur above zurÃ¼ckgeben
            logger.debug(f"Split (above) erfolgreich")
            return body_above
        else:
            # Legacy: Nur below zurÃ¼ckgeben
            logger.debug(f"Split (below) erfolgreich")
            return body_below

    def _compute_thread(self, feature: 'ThreadFeature', current_solid):
        """
        Erzeugt ein echtes helikales Gewinde via Helix-Sweep + Boolean.

        Strategy:
        1. ISO 60Â° Gewindeprofil als Draht erstellen
        2. Helix-Pfad mit Pitch und Tiefe
        3. Sweep Profil entlang Helix â†’ Thread-Solid
        4. Boolean Cut (extern) oder Fuse (intern)
        """
        import numpy as np

        shape = current_solid.wrapped if hasattr(current_solid, 'wrapped') else current_solid

        # TNP v4.0: Face-Referenz auflÃ¶sen (ShapeID -> Index -> Selector).
        target_faces = self._resolve_feature_faces(feature, current_solid)
        has_face_refs = bool(
            getattr(feature, "face_shape_id", None) is not None
            or getattr(feature, "face_index", None) is not None
            or getattr(feature, "face_selector", None)
        )
        if has_face_refs and not target_faces:
            raise ValueError("Thread: Ziel-Face konnte via TNP v4.0 nicht aufgelÃ¶st werden")

        pos = np.array(feature.position, dtype=float)
        direction = np.array(feature.direction, dtype=float)

        if target_faces:
            target_face = target_faces[0]
            try:
                from OCP.BRepAdaptor import BRepAdaptor_Surface
                from OCP.GeomAbs import GeomAbs_Cylinder

                topo_face = target_face.wrapped if hasattr(target_face, "wrapped") else target_face
                adaptor = BRepAdaptor_Surface(topo_face)
                if adaptor.GetType() != GeomAbs_Cylinder:
                    raise ValueError("ausgewÃ¤hltes Face ist nicht zylindrisch")

                cyl = adaptor.Cylinder()
                axis = cyl.Axis()
                axis_loc = axis.Location()
                axis_dir = axis.Direction()

                resolved_axis = np.array([axis_dir.X(), axis_dir.Y(), axis_dir.Z()], dtype=float)
                resolved_axis = resolved_axis / (np.linalg.norm(resolved_axis) + 1e-12)
                if np.linalg.norm(direction) > 1e-9 and np.dot(resolved_axis, direction) < 0:
                    resolved_axis = -resolved_axis

                resolved_origin = np.array([axis_loc.X(), axis_loc.Y(), axis_loc.Z()], dtype=float)
                if np.linalg.norm(pos) > 1e-9:
                    pos = resolved_origin + np.dot(pos - resolved_origin, resolved_axis) * resolved_axis
                else:
                    pos = resolved_origin
                direction = resolved_axis
            except Exception as e:
                logger.warning(f"Thread: Face-Referenz nicht als Zylinder nutzbar ({e}); verwende Feature-Parameter")

        if np.linalg.norm(direction) < 1e-9:
            raise ValueError("Thread: UngÃ¼ltige Gewinderichtung (Nullvektor)")
        direction = direction / (np.linalg.norm(direction) + 1e-12)

        r = max(feature.diameter / 2.0, 1e-6)
        pitch = feature.pitch
        depth = feature.depth
        if pitch <= 1e-9:
            raise ValueError("Thread: Pitch muss > 0 sein")
        if depth <= 0:
            raise ValueError("Thread: Depth muss > 0 sein")
        n_turns = depth / pitch

            # Thread groove depth (ISO 60Â° metric: H = 0.8660 * P, groove = 5/8 * H)
        H = 0.8660254 * pitch
        groove_depth = 0.625 * H

        return self._compute_thread_helix(
            shape, pos, direction, r, pitch, depth, n_turns,
            groove_depth, feature.thread_type, feature.tolerance_offset,
            feature=feature
        )

    def _compute_thread_helix(self, shape, pos, direction, r, pitch, depth, n_turns,
                               groove_depth, thread_type, tolerance_offset, feature=None):
        """Echtes Gewinde via Helix + Sweep mit korrekter Profil-Orientierung.
        
        Das Profil wird senkrecht zum Helix-Tangenten am Startpunkt platziert
        (nicht auf Plane.XZ!). Dadurch entsteht saubere Geometrie mit wenigen
        Faces/Edges â†’ schnelle Tessellation ohne Lag.
        """
        import numpy as np
        from build123d import (Helix, Solid, Polyline, BuildSketch, BuildLine,
                               Plane, make_face, sweep, Vector)
        from modeling.boolean_engine_v4 import BooleanEngineV4
        # BRepAlgoAPI direct import removed in favor of BooleanEngineV4

        logger.debug(f"[THREAD] Helix sweep: r={r:.2f}, pitch={pitch}, depth={depth}, "
                     f"type={thread_type}, groove={groove_depth:.3f}")

        # Helix-Radius: Mitte der Gewinderille
        if thread_type == "external":
            helix_r = r - groove_depth / 2
        else:
            helix_r = r + groove_depth / 2

        # 1. Helix-Pfad via build123d
        helix = Helix(
            pitch=pitch,
            height=depth,
            radius=helix_r,
            center=tuple(pos),
            direction=tuple(direction)
        )

        # 2. ISO 60Â° Dreiecksprofil senkrecht zum Helix-Tangenten am Startpunkt
        half_w = pitch * 0.3

        # Profil-Plane senkrecht zur Helix-Tangente am Startpunkt
        start_pt = helix.position_at(0)
        tangent = helix.tangent_at(0)
        profile_plane = Plane(origin=start_pt, z_dir=tangent)

        with BuildSketch(profile_plane) as profile_sk:
            with BuildLine():
                Polyline(
                    (-groove_depth / 2, -half_w),
                    (groove_depth / 2, 0),
                    (-groove_depth / 2, half_w),
                    close=True
                )
            make_face()

        # 3. Sweep Profil entlang Helix
        thread_solid = sweep(profile_sk.sketch, path=helix)
        thread_ocp = thread_solid.wrapped if hasattr(thread_solid, 'wrapped') else thread_solid

        # 4. Boolean Operation via BooleanEngineV4 (TNP-safe)
        bool_op_type = "Cut" if thread_type == "external" else "Fuse"

        # Tool-Shapes registrieren (optional, aber gut fÃ¼r Debugging/Picking)
        if feature and self._document and hasattr(self._document, '_shape_naming_service'):
            try:
                # Wir registrieren das Tool temporÃ¤r unter der Feature-ID
                self._register_base_feature_shapes(feature, thread_solid)
            except Exception:
                pass

        current_solid_b123d = Solid(shape)
        
        bool_result = BooleanEngineV4.execute_boolean_on_shapes(
            current_solid_b123d, thread_solid, bool_op_type
        )

        if bool_result.is_success:
            result = bool_result.value
            if feature:
                self._register_boolean_history(bool_result, feature, operation_name=f"Thread_{bool_op_type}")
            logger.debug(f"[THREAD] Helix sweep completed successfully (BooleanV4)")
            return result
        else:
            raise RuntimeError(f"Thread boolean via V4 failed: {bool_result.message}")

    def _profile_data_to_face(self, profile_data: dict):
        """
        Konvertiert Profil-Daten zu Build123d Face.

        Args:
            profile_data: Dict mit shapely_poly, plane_origin, plane_normal, etc.

        Returns:
            Build123d Face oder None
        """
        if not profile_data:
            return None

        try:
            from build123d import Plane as B3DPlane, Vector, make_face, Wire, Polyline

            # Plane aus Profil-Daten erstellen
            origin = profile_data.get('plane_origin', (0, 0, 0))
            normal = profile_data.get('plane_normal', (0, 0, 1))
            # WICHTIG: 'plane_x' wird von main_window gesetzt, 'plane_x_dir' ist Fallback
            x_dir = profile_data.get('plane_x') or profile_data.get('plane_x_dir')

            # Validiere normal-Vektor
            normal_vec = Vector(*normal)
            if normal_vec.length < 1e-10:
                logger.warning("Sweep: Normale hat LÃ¤nge 0, verwende (0, 0, 1)")
                normal_vec = Vector(0, 0, 1)

            # x_dir berechnen falls nicht vorhanden oder ungÃ¼ltig
            if not x_dir or Vector(*x_dir).length < 1e-10:
                # Berechne x_dir senkrecht zur Normalen
                import numpy as np
                n = np.array([normal_vec.X, normal_vec.Y, normal_vec.Z])
                n = n / (np.linalg.norm(n) + 1e-10)

                # WÃ¤hle Referenz-Vektor der nicht parallel zur Normalen ist
                if abs(n[2]) < 0.9:
                    ref = np.array([0, 0, 1])
                else:
                    ref = np.array([1, 0, 0])

                x = np.cross(n, ref)
                x = x / (np.linalg.norm(x) + 1e-10)
                x_dir = tuple(x)
                logger.debug(f"Sweep: x_dir berechnet: {x_dir}")

            plane = B3DPlane(
                origin=Vector(*origin),
                z_dir=normal_vec,
                x_dir=Vector(*x_dir)
            )

            # Shapely Polygon zu 3D Wire konvertieren
            shapely_poly = profile_data.get('shapely_poly')
            if shapely_poly is not None:
                # Exterior Ring zu 3D Punkten
                coords = list(shapely_poly.exterior.coords)
                points_3d = []
                for x, y in coords:
                    pt_3d = plane.from_local_coords((x, y))
                    points_3d.append(pt_3d)

                # Ã„uÃŸeres Wire erstellen
                if len(points_3d) >= 3:
                    outer_wire = Wire.make_polygon(points_3d, close=True)

                    # Innere LÃ¶cher verarbeiten (falls vorhanden)
                    inner_wires = []
                    if hasattr(shapely_poly, 'interiors') and shapely_poly.interiors:
                        for interior in shapely_poly.interiors:
                            inner_coords = list(interior.coords)
                            inner_points_3d = []
                            for x, y in inner_coords:
                                pt_3d = plane.from_local_coords((x, y))
                                inner_points_3d.append(pt_3d)
                            if len(inner_points_3d) >= 3:
                                inner_wire = Wire.make_polygon(inner_points_3d, close=True)
                                inner_wires.append(inner_wire)

                    # Face mit LÃ¶chern erstellen
                    if inner_wires:
                        logger.debug(f"Profil hat {len(inner_wires)} innere LÃ¶cher")
                        face = make_face(outer_wire, inner_wires)
                    else:
                        face = make_face(outer_wire)
                    return face

            return None

        except Exception as e:
            logger.debug(f"Profil-zu-Face Konvertierung fehlgeschlagen: {e}")
            return None

    def _canonicalize_sweep_refs(self, feature: 'SweepFeature') -> dict:
        """
        Task 1: Deterministic Reference Canonicalization for Sweep.
        
        Returns kanonisch sortierte Referenzen für:
        - profile_face_index + profile_shape_id
        - path edge_indices + path_shape_id
        
        Returns:
            Dict mit kanonisch sortierten Referenzen für Idempotenz-Checks.
        """
        result = {
            "profile_canonical": None,
            "path_canonical": None,
        }
        
        # Profile Referenzen kanonisieren
        profile_index = getattr(feature, 'profile_face_index', None)
        profile_shape_id = getattr(feature, 'profile_shape_id', None)
        if profile_index is not None or profile_shape_id is not None:
            result["profile_canonical"] = {
                "index": int(profile_index) if profile_index is not None else None,
                "shape_id_uuid": str(profile_shape_id.uuid) if hasattr(profile_shape_id, 'uuid') else None,
            }
        
        # Path Referenzen kanonisieren
        path_data = getattr(feature, 'path_data', {}) or {}
        edge_indices = list(path_data.get('edge_indices', []) or [])
        path_shape_id = getattr(feature, 'path_shape_id', None)
        
        # Edge-Indizes deterministisch sortieren (keine Duplikate, aufsteigend)
        canonical_indices = sorted({int(idx) for idx in edge_indices if isinstance(idx, (int, float)) and int(idx) >= 0})
        
        if canonical_indices or path_shape_id is not None:
            result["path_canonical"] = {
                "edge_indices": canonical_indices,
                "shape_id_uuid": str(path_shape_id.uuid) if hasattr(path_shape_id, 'uuid') else None,
            }
        
        return result

    def _canonicalize_loft_section_refs(self, feature: 'LoftFeature') -> dict:
        """
        Task 1: Deterministic Reference Canonicalization for Loft.
        
        Loft sections können durch face_indices oder section_shape_ids referenziert werden.
        Diese Methode stellt sicher, dass die Reihenfolge deterministisch ist.
        
        Returns:
            Dict mit kanonisch sortierten Section-Referenzen.
        """
        result = {
            "sections_canonical": [],
        }
        
        section_indices = list(getattr(feature, 'section_indices', []) or [])
        section_shape_ids = list(getattr(feature, 'section_shape_ids', []) or [])
        
        # Paare von (index, shape_id) erstellen
        section_pairs = []
        for i, idx in enumerate(section_indices):
            shape_id = section_shape_ids[i] if i < len(section_shape_ids) else None
            section_pairs.append((int(idx) if idx is not None else -1, shape_id))
        
        # Nach Index sortieren für deterministische Reihenfolge
        section_pairs.sort(key=lambda x: x[0])
        
        for idx, shape_id in section_pairs:
            result["sections_canonical"].append({
                "index": idx if idx >= 0 else None,
                "shape_id_uuid": str(shape_id.uuid) if hasattr(shape_id, 'uuid') else None,
            })
        
        return result

    def _canonicalize_edge_refs(self, feature) -> dict:
        """
        Task 1: Deterministic Reference Canonicalization for Edge Features.
        
        Kanonische Sortierung für Fillet/Chamfer Edge-Referenzen.
        
        Returns:
            Dict mit kanonisch sortierten Edge-Referenzen.
        """
        result = {
            "edge_indices_canonical": [],
            "shape_ids_canonical": [],
        }
        
        edge_indices = list(getattr(feature, 'edge_indices', []) or [])
        edge_shape_ids = list(getattr(feature, 'edge_shape_ids', []) or [])
        
        # Edge-Indizes deterministisch sortieren
        result["edge_indices_canonical"] = sorted({
            int(idx) for idx in edge_indices 
            if isinstance(idx, (int, float)) and int(idx) >= 0
        })
        
        # Shape-IDs in stabiler Reihenfolge
        for shape_id in edge_shape_ids:
            if hasattr(shape_id, 'uuid'):
                result["shape_ids_canonical"].append(str(shape_id.uuid))
        
        result["shape_ids_canonical"].sort()
        
        return result

    def _canonicalize_face_refs(self, feature) -> dict:
        """
        Task 1: Deterministic Reference Canonicalization for Face Features.
        
        Kanonische Sortierung für Features mit Face-Referenzen.
        
        Returns:
            Dict mit kanonisch sortierten Face-Referenzen.
        """
        result = {
            "face_indices_canonical": [],
            "shape_ids_canonical": [],
        }
        
        # Verschiedene Attribut-Namen für Face-Features
        face_indices_attrs = ['face_indices', 'opening_face_indices']
        face_shape_ids_attrs = ['face_shape_ids', 'opening_face_shape_ids']
        
        face_indices = []
        face_shape_ids = []
        
        for attr in face_indices_attrs:
            if hasattr(feature, attr):
                val = getattr(feature, attr)
                if val is not None:
                    face_indices = list(val) if not isinstance(val, (int, float)) else [val]
                    break
        
        for attr in face_shape_ids_attrs:
            if hasattr(feature, attr):
                val = getattr(feature, attr)
                if val is not None:
                    face_shape_ids = list(val) if not isinstance(val, (int, float)) else [val]
                    break
        
        # Face-Indizes deterministisch sortieren
        result["face_indices_canonical"] = sorted({
            int(idx) for idx in face_indices 
            if isinstance(idx, (int, float)) and int(idx) >= 0
        })
        
        # Shape-IDs in stabiler Reihenfolge
        for shape_id in face_shape_ids:
            if hasattr(shape_id, 'uuid'):
                result["shape_ids_canonical"].append(str(shape_id.uuid))
        
        result["shape_ids_canonical"].sort()
        
        return result

    def _update_edge_selectors_after_operation(self, solid, current_feature_index: int = -1):
        """
        Aktualisiert Edge-Selektoren in Fillet/Chamfer Features nach Geometrie-Operation.

        Nach Push/Pull oder Boolean Ã¤ndern sich Edge-Positionen. Diese Methode
        findet die neuen Edges und aktualisiert die gespeicherten GeometricEdgeSelectors.

        Bei groÃŸen Parameter-Ã„nderungen (z.B. Extrude 200â†’100mm) wird automatisch
        adaptive Toleranz verwendet wenn Standard-Matching (10mm) fehlschlÃ¤gt.

        Args:
            solid: Das neue Solid nach der Operation
            current_feature_index: Index des aktuell angewandten Features im Rebuild.
                Nur Features VOR diesem Index werden aktualisiert (die danach
                werden bei ihrem eigenen Durchlauf aktualisiert).
                -1 = alle aktualisieren (Backward-Compat fÃ¼r nicht-Rebuild Aufrufe).
        """
        if not solid or not hasattr(solid, 'edges'):
            return

        all_edges = list(solid.edges())
        if not all_edges:
            return

        from modeling.geometric_selector import GeometricEdgeSelector

        adaptive_tolerance = None  # Lazy-computed bei Bedarf

        updated_count = 0
        for feat_idx, feature in enumerate(self.features):
            # Beim Rebuild: Nur Features aktualisieren die VOR dem aktuellen
            # Feature liegen. Features danach werden bei ihrem eigenen Durchlauf
            # ihre Edges im dann-aktuellen Solid finden.
            if current_feature_index >= 0 and feat_idx >= current_feature_index:
                continue
            # Nur Fillet und Chamfer Features
            if not isinstance(feature, (FilletFeature, ChamferFeature)):
                continue

            geometric_selectors = getattr(feature, 'geometric_selectors', [])
            if not geometric_selectors:
                continue

            edge_shape_ids = getattr(feature, 'edge_shape_ids', [])

            new_selectors = []
            for idx, selector in enumerate(geometric_selectors):
                try:
                    # Konvertiere zu GeometricEdgeSelector wenn nÃ¶tig
                    if isinstance(selector, dict):
                        geo_sel = GeometricEdgeSelector.from_dict(selector)
                    elif hasattr(selector, 'find_best_match'):
                        geo_sel = selector
                    else:
                        continue

                    # Finde beste matching Edge im neuen Solid
                    best_edge = geo_sel.find_best_match(all_edges)

                    # Rebuild-Fallback: Adaptive Toleranz bei Parameter-Ã„nderungen
                    if best_edge is None:
                        if adaptive_tolerance is None:
                            adaptive_tolerance = self._compute_adaptive_edge_tolerance(solid)

                        if adaptive_tolerance > geo_sel.tolerance:
                            adaptive_sel = GeometricEdgeSelector(
                                center=geo_sel.center,
                                direction=geo_sel.direction,
                                length=geo_sel.length,
                                curve_type=geo_sel.curve_type,
                                tolerance=adaptive_tolerance
                            )
                            best_edge = adaptive_sel.find_best_match(all_edges)
                            if best_edge is not None:
                                logger.debug(f"Edge via adaptive Toleranz ({adaptive_tolerance:.1f}mm) gefunden")

                    if best_edge is not None:
                        # Erstelle neuen Selector mit aktualisierten Werten
                        new_selector = GeometricEdgeSelector.from_edge(best_edge)
                        new_selectors.append(new_selector)
                        updated_count += 1

                        # TNP v4.0: ShapeNamingService Record aktualisieren
                        if idx < len(edge_shape_ids):
                            self._update_shape_naming_record(edge_shape_ids[idx], best_edge)

                        # TNP v4.0: Topology-Index aktualisieren
                        try:
                            edge_indices = getattr(feature, "edge_indices", None)
                            if edge_indices is not None and idx < len(edge_indices):
                                for edge_idx, candidate in enumerate(all_edges):
                                    if self._is_same_edge(candidate, best_edge):
                                        edge_indices[idx] = edge_idx
                                        break
                        except Exception:
                            pass
                    else:
                        # Edge nicht gefunden - behalte alten Selector bei
                        logger.warning(f"Edge nicht gefunden nach Operation fÃ¼r {feature.name}")
                        new_selectors.append(geo_sel)
                except Exception as e:
                    logger.debug(f"Edge-Selector Update fehlgeschlagen: {e}")
                    if isinstance(selector, dict):
                        new_selectors.append(GeometricEdgeSelector.from_dict(selector))
                    else:
                        new_selectors.append(selector)

            # Aktualisiere Feature
            feature.geometric_selectors = new_selectors

        if updated_count > 0:
            logger.info(f"Aktualisiert {updated_count} Edge-Selektoren nach Geometrie-Operation")

    def _update_edge_selectors_for_feature(self, feature, solid):
        """
        Aktualisiert Edge-Selektoren eines SPEZIFISCHEN Features vor AusfÃ¼hrung.

        TNP-CRITICAL: Diese Methode muss BEVOR Fillet/Chamfer ausgefÃ¼hrt werden,
        weil das Solid sich durch vorherige Features verÃ¤ndert haben kann.

        Bei Parameter-Ã„nderungen (z.B. Extrude 200â†’100mm) kÃ¶nnen Edge-Center um
        mehr als die Standard-Toleranz (10mm) wandern. In diesem Fall wird ein
        adaptiver Fallback verwendet, der die Toleranz an die Solid-GrÃ¶ÃŸe anpasst.

        Args:
            feature: FilletFeature oder ChamferFeature
            solid: Das aktuelle Solid (nach allen vorherigen Features)
        """
        if not solid or not hasattr(solid, 'edges'):
            return

        all_edges = list(solid.edges())
        if not all_edges:
            return

        from modeling.geometric_selector import GeometricEdgeSelector

        geometric_selectors = getattr(feature, 'geometric_selectors', [])
        if not geometric_selectors:
            return

        edge_shape_ids = getattr(feature, 'edge_shape_ids', [])
        adaptive_tolerance = None  # Lazy-computed bei Bedarf

        updated_count = 0
        new_selectors = []

        for idx, selector in enumerate(geometric_selectors):
            try:
                # Konvertiere zu GeometricEdgeSelector wenn nÃ¶tig
                if isinstance(selector, dict):
                    geo_sel = GeometricEdgeSelector.from_dict(selector)
                elif hasattr(selector, 'find_best_match'):
                    geo_sel = selector
                else:
                    new_selectors.append(selector)
                    continue

                # Finde beste matching Edge im aktuellen Solid
                best_edge = geo_sel.find_best_match(all_edges)

                # Rebuild-Fallback: Adaptive Toleranz bei Parameter-Ã„nderungen
                # Wenn Standard-Matching (10mm) fehlschlÃ¤gt, Toleranz an Solid-GrÃ¶ÃŸe anpassen
                if best_edge is None:
                    if adaptive_tolerance is None:
                        adaptive_tolerance = self._compute_adaptive_edge_tolerance(solid)

                    if adaptive_tolerance > geo_sel.tolerance:
                        adaptive_sel = GeometricEdgeSelector(
                            center=geo_sel.center,
                            direction=geo_sel.direction,
                            length=geo_sel.length,
                            curve_type=geo_sel.curve_type,
                            tolerance=adaptive_tolerance
                        )
                        best_edge = adaptive_sel.find_best_match(all_edges)
                        if best_edge is not None:
                            logger.debug(f"Edge via adaptive Toleranz ({adaptive_tolerance:.1f}mm) gefunden")

                if best_edge is not None:
                    # Erstelle neuen Selector mit aktualisierten Werten
                    new_selector = GeometricEdgeSelector.from_edge(best_edge)
                    new_selectors.append(new_selector)
                    updated_count += 1

                    # TNP v4.0: ShapeNamingService Record aktualisieren
                    if idx < len(edge_shape_ids):
                        old_sid = edge_shape_ids[idx]
                        self._update_shape_naming_record(old_sid, best_edge)

                        # Wenn UUID nach Rebuild-Invalidierung nicht mehr im
                        # Registry ist, neue ShapeID registrieren und
                        # edge_shape_ids aktualisieren.
                        if (self._document
                                and hasattr(self._document, '_shape_naming_service')):
                            svc = self._document._shape_naming_service
                            if hasattr(old_sid, 'uuid') and old_sid.uuid not in svc._shapes:
                                new_sid = svc.register_shape(
                                    ocp_shape=best_edge.wrapped if hasattr(best_edge, 'wrapped') else best_edge,
                                    shape_type=ShapeType.EDGE,
                                    feature_id=getattr(old_sid, 'feature_id', getattr(feature, 'id', '')),
                                    local_index=getattr(old_sid, 'local_index', idx),
                                )
                                edge_shape_ids[idx] = new_sid
                                if is_enabled("tnp_debug_logging"):
                                    logger.debug(
                                        f"ShapeID erneuert nach Rebuild: "
                                        f"{old_sid.uuid[:8]} â†’ {new_sid.uuid[:8]}"
                                    )

                    # TNP v4.0: Topology-Index aktualisieren
                    try:
                        edge_indices = getattr(feature, "edge_indices", None)
                        if edge_indices is not None and idx < len(edge_indices):
                            for edge_idx, candidate in enumerate(all_edges):
                                if self._is_same_edge(candidate, best_edge):
                                    edge_indices[idx] = edge_idx
                                    break
                    except Exception:
                        pass
                else:
                    # Edge nicht gefunden - behalte alten Selector bei
                    logger.debug(f"Edge nicht gefunden fÃ¼r Feature {feature.name}, behalte alten Selector")
                    new_selectors.append(geo_sel)
            except Exception as e:
                logger.debug(f"Edge-Selector Update fehlgeschlagen: {e}")
                new_selectors.append(selector)

        # Aktualisiere Feature
        feature.geometric_selectors = new_selectors

        if updated_count > 0:
            logger.debug(f"Feature '{feature.name}': {updated_count}/{len(geometric_selectors)} Edges aktualisiert")

    def _compute_adaptive_edge_tolerance(self, solid) -> float:
        """
        Berechnet adaptive Toleranz fÃ¼r Edge-Matching basierend auf Solid-GrÃ¶ÃŸe.

        BESSER LÃ–SUNG: Statt das adaptive Toleranz-Ansatz zu verwenden, verlassen wir uns
        auf verbessertes TNP-Tracking (face_id-basierte Gruppierung, .wrapped Fix, etc.).

        Die adaptive Toleranz wird nur als letzten Fallback verwendet und ist STRENG begrenzt
        um falsche Edge-Matches zu vermeiden.

        Max: 15mm (statt 50mm) - verhindert dass vÃ¶llig falsche Edges gematcht werden.
        """
        try:
            bbox = solid.bounding_box()
            max_dim = max(
                bbox.max.X - bbox.min.X,
                bbox.max.Y - bbox.min.Y,
                bbox.max.Z - bbox.min.Z
            )
            # Adaptive Toleranz = 5% der grÃ¶ÃŸten Dimension, min 5mm, max 15mm
            # (frÃ¼her: 10% max 50mm - zu groÃŸ fÃ¼r prÃ¤zise Fillets!)
            tolerance = max_dim / 20.0
            return max(5.0, min(tolerance, 15.0))
        except Exception:
            return 10.0

    def _update_shape_naming_record(self, shape_id, edge) -> None:
        """
        Aktualisiert einen ShapeNamingService Record mit neuer Edge-Geometrie.

        Wird aufgerufen wenn ein Edge-Selector nach Parameter-Ã„nderung eine neue
        passende Edge gefunden hat. Aktualisiert ocp_shape, geometric_signature
        und spatial_index, damit _resolve_edges_tnp die Edge ebenfalls findet.
        """
        if not self._document or not hasattr(self._document, '_shape_naming_service'):
            return

        try:
            service = self._document._shape_naming_service

            if not hasattr(shape_id, 'uuid') or shape_id.uuid not in service._shapes:
                return

            record = service._shapes[shape_id.uuid]

            # OCP Shape aktualisieren
            record.ocp_shape = edge.wrapped
            record.is_valid = True

            # Geometric Signature neu berechnen
            old_sig = record.geometric_signature.copy() if record.geometric_signature else {}
            record.geometric_signature = record.compute_signature()

            # Spatial Index aktualisieren
            shape_type = record.shape_id.shape_type
            if 'center' in record.geometric_signature:
                import numpy as np
                new_center = np.array(record.geometric_signature['center'])

                # Alten Eintrag entfernen
                service._spatial_index[shape_type] = [
                    (pos, sid) for pos, sid in service._spatial_index[shape_type]
                    if sid.uuid != shape_id.uuid
                ]
                # Neuen Eintrag hinzufÃ¼gen
                service._spatial_index[shape_type].append((new_center, record.shape_id))

            if is_enabled("tnp_debug_logging"):
                logger.debug(f"TNP Record {shape_id.uuid[:8]} aktualisiert nach Parameter-Ã„nderung")

        except Exception as e:
            logger.debug(f"Shape Naming Record Update fehlgeschlagen: {e}")

    def _register_extrude_shapes(self, feature: 'ExtrudeFeature', solid) -> None:
        """
        TNP v4.0: Registriert alle Edges und Faces eines Extrude-Solids im NamingService.
        Wird nach erfolgreicher Extrusion aufgerufen.
        """
        if not self._document or not hasattr(self._document, '_shape_naming_service'):
            return
        
        if not solid or not hasattr(solid, 'edges'):
            return
        
        try:
            service = self._document._shape_naming_service
            edges = list(solid.edges())
            
            shape_ids = []
            for i, edge in enumerate(edges):
                # Extrahiere Geometriedaten
                center = edge.center()
                length = edge.length if hasattr(edge, 'length') else 0.0
                geometry_data = (center.X, center.Y, center.Z, length)
                
                # Registriere Shape
                shape_id = service.register_shape(
                    ocp_shape=edge.wrapped,
                    shape_type=ShapeType.EDGE,
                    feature_id=feature.id,
                    local_index=i,
                    geometry_data=geometry_data
                )
                shape_ids.append(shape_id)
            
            # Faces registrieren
            face_count = 0
            try:
                from OCP.TopTools import TopTools_IndexedMapOfShape
                from OCP.TopExp import TopExp
                from OCP.TopoDS import TopoDS

                solid_wrapped = solid.wrapped if hasattr(solid, 'wrapped') else solid
                face_map = TopTools_IndexedMapOfShape()
                TopExp.MapShapes_s(solid_wrapped, TopAbs_FACE, face_map)

                for fi in range(1, face_map.Extent() + 1):
                    face = TopoDS.Face_s(face_map.FindKey(fi))
                    service.register_shape(face, ShapeType.FACE, feature.id, fi - 1)
                    face_count += 1
            except Exception as e:
                if is_enabled("tnp_debug_logging"):
                    logger.debug(f"TNP v4.0: Extrude Face-Registrierung fehlgeschlagen: {e}")

            # Operation aufzeichnen
            service.record_operation(
                OperationRecord(
                    operation_id=feature.id,
                    operation_type="EXTRUDE",
                    feature_id=feature.id,
                    input_shape_ids=[],  # Extrude hat keine Input-Edges
                    output_shape_ids=shape_ids
                )
            )
            
            if is_enabled("tnp_debug_logging"):
                logger.info(f"TNP v4.0: {len(shape_ids)} Edges, {face_count} Faces fÃ¼r Extrude '{feature.name}' registriert")
            
        except Exception as e:
            if is_enabled("tnp_debug_logging"):
                logger.warning(f"TNP v4.0: Extrude-Registrierung fehlgeschlagen: {e}")

    def _register_base_feature_shapes(self, feature, solid) -> None:
        """
        TNP v4.0: Registriert alle Edges UND Faces eines neu erzeugten Solids fuer Basis-Features
        (Loft, Revolve, Sweep, Primitive, Import). Nur einmal pro Feature-ID.
        """
        if not self._document or not hasattr(self._document, '_shape_naming_service'):
            return
        if not solid or not hasattr(solid, 'edges'):
            return

        try:
            service = self._document._shape_naming_service
            if service.get_shapes_by_feature(feature.id):
                return

            # Edges registrieren
            edge_count = service.register_solid_edges(solid, feature.id)

            # Faces registrieren
            face_count = 0
            try:
                from OCP.TopTools import TopTools_IndexedMapOfShape
                from OCP.TopExp import TopExp
                from OCP.TopoDS import TopoDS

                solid_wrapped = solid.wrapped if hasattr(solid, 'wrapped') else solid
                face_map = TopTools_IndexedMapOfShape()
                TopExp.MapShapes_s(solid_wrapped, TopAbs_FACE, face_map)

                for i in range(1, face_map.Extent() + 1):
                    face = TopoDS.Face_s(face_map.FindKey(i))
                    service.register_shape(face, ShapeType.FACE, feature.id, i - 1)
                    face_count += 1
            except Exception as e:
                if is_enabled("tnp_debug_logging"):
                    logger.debug(f"TNP v4.0: Face-Registrierung fehlgeschlagen: {e}")

            if is_enabled("tnp_debug_logging"):
                logger.info(f"TNP v4.0: Base-Feature '{feature.id[:8]}': {edge_count} Edges, {face_count} Faces registriert")
        except Exception as e:
            if is_enabled("tnp_debug_logging"):
                logger.debug(f"TNP v4.0: Base-Feature Registrierung fehlgeschlagen: {e}")

    def _register_brepfeat_operation(self, feature, original_solid, result_solid,
                                     input_shape, result_shape) -> None:
        """
        TNP v4.0: Registriert eine BRepFeat-Operation mit Edge-Mappings.
        Wichtig: Ordnet Original-Edges den neuen Edges im Resultat zu.
        """
        if not self._document or not hasattr(self._document, '_shape_naming_service'):
            return
        
        try:
            service = self._document._shape_naming_service
            
            # 1. Alle Original-Edges registrieren (falls noch nicht geschehen)
            input_shape_ids = []
            if original_solid and hasattr(original_solid, 'edges'):
                for i, edge in enumerate(original_solid.edges()):
                    center = edge.center()
                    length = edge.length if hasattr(edge, 'length') else 0.0
                    geometry_data = (center.X, center.Y, center.Z, length)
                    
                    shape_id = service.register_shape(
                        ocp_shape=edge.wrapped,
                        shape_type=ShapeType.EDGE,
                        feature_id=feature.id,
                        local_index=i,
                        geometry_data=geometry_data
                    )
                    input_shape_ids.append(shape_id)
            
            # 2. Alle Result-Edges registrieren
            output_shape_ids = []
            if result_solid and hasattr(result_solid, 'edges'):
                for i, edge in enumerate(result_solid.edges()):
                    center = edge.center()
                    length = edge.length if hasattr(edge, 'length') else 0.0
                    geometry_data = (center.X, center.Y, center.Z, length)
                    
                    shape_id = service.register_shape(
                        ocp_shape=edge.wrapped,
                        shape_type=ShapeType.EDGE,
                        feature_id=feature.id,
                        local_index=i + len(input_shape_ids),  # Offset
                        geometry_data=geometry_data
                    )
                    output_shape_ids.append(shape_id)
            
            # 3. Manuelle Mappings erstellen (geometrisches Matching)
            # Finde fÃ¼r jede Original-Edge die beste passende Result-Edge
            manual_mappings = {}
            
            if original_solid and result_solid:
                import numpy as np
                
                orig_edges = list(original_solid.edges())
                result_edges = list(result_solid.edges())
                
                for i, orig_edge in enumerate(orig_edges):
                    orig_center = orig_edge.center()
                    orig_pos = np.array([orig_center.X, orig_center.Y, orig_center.Z])
                    orig_len = orig_edge.length if hasattr(orig_edge, 'length') else 0
                    
                    # Suche beste Matching Result-Edge
                    best_match_idx = -1
                    best_score = float('inf')
                    
                    for j, result_edge in enumerate(result_edges):
                        result_center = result_edge.center()
                        result_pos = np.array([result_center.X, result_center.Y, result_center.Z])
                        result_len = result_edge.length if hasattr(result_edge, 'length') else 0
                        
                        # Distanz-Score
                        dist = np.linalg.norm(orig_pos - result_pos)
                        
                        # LÃ¤ngen-Score
                        len_diff = abs(orig_len - result_len) if orig_len > 0 else 0
                        
                        # Gesamt-Score (Distanz wichtiger)
                        score = dist + len_diff * 0.1
                        
                        if score < best_score and score < 1.0:  # 1mm Toleranz
                            best_score = score
                            best_match_idx = j
                    
                    if best_match_idx >= 0 and i < len(input_shape_ids):
                        orig_id = input_shape_ids[i].uuid
                        mapped_id = output_shape_ids[best_match_idx].uuid
                        manual_mappings[orig_id] = [mapped_id]
            
            # 4. Operation aufzeichnen
            service.record_operation(
                OperationRecord(
                    operation_id=feature.id,
                    operation_type="BREPFEAT_PRISM",
                    feature_id=feature.id,
                    input_shape_ids=input_shape_ids,
                    output_shape_ids=output_shape_ids,
                    manual_mappings=manual_mappings
                )
            )
            
            if is_enabled("tnp_debug_logging"):
                logger.info(f"TNP v4.0: BRepFeat '{feature.name}' registriert - "
                           f"{len(input_shape_ids)} in, {len(output_shape_ids)} out, "
                           f"{len(manual_mappings)} mappings")
            
        except Exception as e:
            if is_enabled("tnp_debug_logging"):
                logger.warning(f"TNP v4.0: BRepFeat-Registrierung fehlgeschlagen: {e}")
                import traceback
                logger.debug(traceback.format_exc())

    def _update_face_selectors_for_feature(self, feature, solid):
        """
        TNP v4.0: Aktualisiert Face-Referenzen eines Features vor AusfÃ¼hrung.

        Primary: ShapeIDs via ShapeNamingService
        Secondary: Face-Indizes via topology_indexing.face_from_index
        Fallback: GeometricFaceSelector (nur Legacy-Recovery)
        """
        if not solid:
            return

        if not isinstance(
            feature,
            (
                ShellFeature,
                HoleFeature,
                DraftFeature,
                HollowFeature,
                ThreadFeature,
                SurfaceTextureFeature,
                ExtrudeFeature,
            ),
        ):
            return

        resolved_faces = self._resolve_feature_faces(feature, solid)
        if is_enabled("tnp_debug_logging"):
            logger.debug(f"{feature.name}: {len(resolved_faces)} Face-Referenzen aufgelÃ¶st (TNP v4.0)")

    def _get_or_create_shape_naming_service(self):
        """
        Liefert den aktiven ShapeNamingService oder erstellt einen temporÃ¤ren.

        Legacy-Compat: Direkte _ocp_fillet/_ocp_chamfer-Aufrufe aus
        Regressionstests kÃ¶nnen ohne Document-Kontext auftreten.
        """
        if self._document and hasattr(self._document, "_shape_naming_service"):
            service = self._document._shape_naming_service
            if service is not None:
                return service
        return ShapeNamingService()

    def _ocp_extrude_face(self, face, amount, direction):
        """
        Extrusion eines Faces - nutzt Build123d primÃ¤r, OCP als Fallback.

        Args:
            face: Build123d Face oder TopoDS_Face
            amount: Extrusions-Distanz (positiv oder negativ)
            direction: Richtungsvektor (Build123d Vector oder Tuple)

        Returns:
            Build123d Solid oder None
        """
        # PRIMÃ„R: Build123d extrude (bewÃ¤hrt und stabil)
        try:
            from build123d import extrude
            result = extrude(face, amount=amount, dir=direction)
            if result and hasattr(result, 'is_valid') and result.is_valid():
                return result
            elif result:
                # Versuche Reparatur
                try:
                    result = result.fix()
                    if result.is_valid():
                        return result
                except Exception as e:
                    logger.debug(f"[__init__.py] Fehler: {e}")
                    pass
        except Exception as e:
            logger.debug(f"Build123d extrude fehlgeschlagen: {e}")

        # FALLBACK: OCP MakePrism
        if not HAS_OCP:
            return None

        try:
            from OCP.BRepPrimAPI import BRepPrimAPI_MakePrism
            from OCP.gp import gp_Vec
            from OCP.BRepCheck import BRepCheck_Analyzer

            logger.debug("Versuche OCP Extrude Fallback...")

            # Extrahiere TopoDS_Face
            if hasattr(face, 'wrapped'):
                topo_face = face.wrapped
            else:
                topo_face = face

            # Erstelle Richtungsvektor
            try:
                if hasattr(direction, 'X'):
                    # Build123d Vector (property mit GroÃŸbuchstaben)
                    vec = gp_Vec(direction.X * amount, direction.Y * amount, direction.Z * amount)
                elif hasattr(direction, 'x'):
                    # Objekt mit x, y, z Attributen (Kleinbuchstaben)
                    vec = gp_Vec(direction.x * amount, direction.y * amount, direction.z * amount)
                elif isinstance(direction, (list, tuple)) and len(direction) == 3:
                    vec = gp_Vec(direction[0] * amount, direction[1] * amount, direction[2] * amount)
                else:
                    logger.error(f"Unbekannter direction-Typ: {type(direction)}")
                    return None
            except Exception as e:
                logger.error(f"Fehler bei Vektor-Konvertierung: {e}")
                return None

            # OCP Prism (Extrusion)
            prism = BRepPrimAPI_MakePrism(topo_face, vec)
            prism.Build()

            if not prism.IsDone():
                logger.warning("OCP MakePrism IsDone() = False")
                return None

            result_shape = prism.Shape()

            # Validiere
            analyzer = BRepCheck_Analyzer(result_shape)
            if not analyzer.IsValid():
                logger.warning("OCP Extrude produzierte ungÃ¼ltiges Shape, versuche Reparatur...")
                result_shape = self._fix_shape_ocp(result_shape)

            # Wrap zu Build123d Solid
            try:
                from build123d import Solid, Shape
                try:
                    result = Solid(result_shape)
                except Exception as e:
                    logger.debug(f"[__init__.py] Fehler: {e}")
                    result = Shape(result_shape)

                if hasattr(result, 'is_valid') and result.is_valid():
                    return result
                else:
                    # Versuche fix()
                    try:
                        result = result.fix()
                        if result.is_valid():
                            return result
                    except Exception as e:
                        logger.debug(f"[__init__.py] Fehler: {e}")
                        pass
                    logger.warning("OCP Extrude Resultat invalid")
                    return None
            except Exception as e:
                logger.error(f"Wrap zu Build123d fehlgeschlagen: {e}")
                return None

        except Exception as e:
            logger.error(f"OCP Extrude Fehler: {e}")
            import traceback
            traceback.print_exc()
            return None

    def _ocp_fillet(self, solid, edges, radius, feature_id: Optional[str] = None):
        """
        Legacy-kompatibler Fillet-Entry-Point.

        Delegiert auf OCPFilletHelper, damit Ã¤ltere Tests/Callsites
        weiterhin funktionieren.
        """
        if solid is None:
            raise ValueError("_ocp_fillet: solid darf nicht None sein")

        naming_service = self._get_or_create_shape_naming_service()
        if feature_id is None:
            feature_id = f"fillet_compat_{self.id}"

        return OCPFilletHelper.fillet(
            solid=solid,
            edges=edges or [],
            radius=radius,
            naming_service=naming_service,
            feature_id=feature_id,
        )

    def _ocp_chamfer(self, solid, edges, distance, feature_id: Optional[str] = None):
        """
        Legacy-kompatibler Chamfer-Entry-Point.

        Delegiert auf OCPChamferHelper, damit Ã¤ltere Tests/Callsites
        weiterhin funktionieren.
        """
        if solid is None:
            raise ValueError("_ocp_chamfer: solid darf nicht None sein")

        naming_service = self._get_or_create_shape_naming_service()
        if feature_id is None:
            feature_id = f"chamfer_compat_{self.id}"

        return OCPChamferHelper.chamfer(
            solid=solid,
            edges=edges or [],
            distance=distance,
            naming_service=naming_service,
            feature_id=feature_id,
        )

    def update_feature_references(self, feature_id: str, old_solid, new_solid):
        """
        KompatibilitÃ¤ts-Hook bei Feature-Ã„nderungen.

        Args:
            feature_id: ID des modifizierten Features
            old_solid: Solid VOR der Ã„nderung
            new_solid: Solid NACH der Ã„nderung
        """
        if is_enabled("tnp_debug_logging"):
            logger.debug(f"TNP v4.0: Feature {feature_id} wurde modifiziert")

    def reorder_features(self, old_index: int, new_index: int) -> bool:
        """
        Verschiebt ein Feature in der Liste und fÃ¼hrt Migration durch.

        Args:
            old_index: Aktuelle Position
            new_index: Neue Position

        Returns:
            True bei Erfolg
        """
        if old_index < 0 or old_index >= len(self.features):
            return False
        if new_index < 0 or new_index >= len(self.features):
            return False
        if old_index == new_index:
            return True

        # Speichere alte Referenzen
        old_solid = self._build123d_solid

        # Feature verschieben
        feature = self.features.pop(old_index)
        self.features.insert(new_index, feature)

        logger.info(f"Feature '{feature.name}' verschoben: {old_index} â†’ {new_index}")

        # Rebuild ausfÃ¼hren (inkl. automatischer Migration)
        try:
            self._rebuild()
            return True
        except Exception as e:
            logger.error(f"Rebuild nach Feature-Verschiebung fehlgeschlagen: {e}")
            # RÃ¼ckgÃ¤ngig machen
            feature = self.features.pop(new_index)
            self.features.insert(old_index, feature)
            self._rebuild()
            return False

    def _apply_transform_feature(self, solid, feature: TransformFeature):
        """
        Wendet ein TransformFeature auf einen Solid an.

        Args:
            solid: build123d Solid
            feature: TransformFeature mit mode und data

        Returns:
            Transformierter Solid
        """
        from build123d import Location, Axis, Plane as B123Plane

        mode = feature.mode
        data = feature.data

        try:
            if mode == "move":
                # Translation: [dx, dy, dz]
                translation = data.get("translation", [0, 0, 0])
                tx, ty, tz = translation
                return solid.move(Location((tx, ty, tz)))

            elif mode == "rotate":
                # Rotation: {"axis": "X/Y/Z", "angle": degrees, "center": [x, y, z]}
                axis_name = data.get("axis", "Z")
                angle = data.get("angle", 0)
                center = data.get("center", [0, 0, 0])

                # Build123d Axis Mapping
                axis_map = {
                    "X": Axis.X,
                    "Y": Axis.Y,
                    "Z": Axis.Z
                }
                axis = axis_map.get(axis_name, Axis.Z)

                # Rotation um beliebigen Punkt:
                # 1. Move to origin
                # 2. Rotate
                # 3. Move back
                cx, cy, cz = center
                solid = solid.move(Location((-cx, -cy, -cz)))
                solid = solid.rotate(axis, angle)
                solid = solid.move(Location((cx, cy, cz)))
                return solid

            elif mode == "scale":
                # Scale: {"factor": float, "center": [x, y, z]}
                factor = data.get("factor", 1.0)
                center = data.get("center", [0, 0, 0])

                cx, cy, cz = center
                solid = solid.move(Location((-cx, -cy, -cz)))
                solid = solid.scale(factor)
                solid = solid.move(Location((cx, cy, cz)))
                return solid

            elif mode == "mirror":
                # Mirror: {"plane": "XY/XZ/YZ"}
                plane_name = data.get("plane", "XY")

                # Build123d Plane Mapping
                plane_map = {
                    "XY": B123Plane.XY,
                    "XZ": B123Plane.XZ,
                    "YZ": B123Plane.YZ
                }
                plane = plane_map.get(plane_name, B123Plane.XY)

                return solid.mirror(plane)

            else:
                logger.warning(f"Unbekannter Transform-Modus: {mode}")
                return solid

        except Exception as e:
            logger.error(f"Transform-Feature-Fehler ({mode}): {e}")
            raise

    def _convert_line_profiles_to_polygons(self, line_profiles: list) -> list:
        """Delegates to shape_builders module - see convert_line_profiles_to_polygons."""
        return convert_line_profiles_to_polygons(line_profiles)

    def _filter_profiles_by_selector(self, profiles: list, selector: list, tolerance: float = 5.0) -> list:
        """Delegates to shape_builders module - see filter_profiles_by_selector."""
        return filter_profiles_by_selector(profiles, selector, tolerance)

    def _detect_circle_from_points(self, points, tolerance=0.02):
        """
        Erkennt ob ein Polygon eigentlich ein Kreis ist.
        
        Args:
            points: Liste von (x, y) Tupeln
            tolerance: Relative Toleranz fÃ¼r Radius-Varianz (2% default)
            
        Returns:
            (cx, cy, radius) wenn es ein Kreis ist, sonst None
        """
        import numpy as np
        
        # Circle-Erkennung nur bei dichter Approximation aktivieren.
        # 12-seitige Polygone sollen als Polygon erhalten bleiben (Regression-Trust).
        if len(points) < 24:
            return None
        
        pts = np.array(points)
        
        # Schwerpunkt berechnen
        cx = np.mean(pts[:, 0])
        cy = np.mean(pts[:, 1])
        
        # AbstÃ¤nde zum Schwerpunkt
        distances = np.sqrt((pts[:, 0] - cx)**2 + (pts[:, 1] - cy)**2)
        
        # Mittlerer Radius
        radius = np.mean(distances)
        
        if radius < 0.1:  # Zu klein
            return None
        
        # Varianz prÃ¼fen (sollte sehr klein sein fÃ¼r Kreis)
        variance = np.std(distances) / radius
        
        logger.debug(f"_detect_circle: {len(points)} Punkte, r={radius:.2f}, varianz={variance:.6f}")
        
        if variance < tolerance:
            # Es ist ein Kreis!
            return (float(cx), float(cy), float(radius))

        return None

    def _create_faces_from_native_circles(self, sketch, plane, profile_selector=None):
        """
        TNP v4.1: Erstellt native OCP Circle Faces aus Sketch-Kreisen.

        Wenn Kreise native_ocp_data haben, werden direkt native OCP Circle Faces
        erstellt (3 Faces statt 14+ durch Polygon-Approximation).

        Args:
            sketch: Sketch-Objekt mit circles Liste
            plane: Build123d Plane fÃ¼r 3D-Konvertierung
            profile_selector: Optional selector for filtering circles

        Returns:
            Liste von build123d Faces aus nativen OCP Circles
        """
        from build123d import Plane as B3DPlane, Wire, make_face, Vector

        faces = []
        circles_with_native_data = [
            c for c in sketch.circles
            if hasattr(c, 'native_ocp_data') and c.native_ocp_data
        ]

        if not circles_with_native_data:
            return []

        logger.info(f"[TNP v4.1] {len(circles_with_native_data)} Kreise mit native_ocp_data gefunden")

        for circle in circles_with_native_data:
            if circle.construction:
                continue  # Konstruktions-Kreise nicht extrudieren

            ocp_data = circle.native_ocp_data
            cx, cy = ocp_data['center']
            radius = ocp_data['radius']

            # Profiler-Selektor Matching (fÃ¼r selektive Extrusion)
            if profile_selector:
                # Selektor enthÃ¤lt Centroids der gewÃ¤hlten Profile
                circle_centroid = (cx, cy)
                if not any(
                    abs(circle_centroid[0] - sel[0]) < 0.1 and
                    abs(circle_centroid[1] - sel[1]) < 0.1
                    for sel in profile_selector
                ):
                    continue  # Circle nicht selektiert

            # WICHTIG: AKTUELLE Plane-Orientation vom Sketch verwenden!
            # Die native_ocp_data['plane'] kann veraltet sein (GUI rotiert die Plane nach dem HinzufÃ¼gen)
            origin = Vector(*sketch.plane_origin)
            z_dir = Vector(*sketch.plane_normal)
            x_dir = Vector(*sketch.plane_x_dir)
            y_dir = Vector(*sketch.plane_y_dir)

            # FIX: Wenn y_dir Nullvektor ist (Bug), aus z_dir und x_dir berechnen
            if y_dir.X == 0 and y_dir.Y == 0 and y_dir.Z == 0:
                y_dir = z_dir.cross(x_dir)
                logger.debug(f"[TNP v4.1] y_dir aus z_dir Ã— x_dir berechnet: ({y_dir.X:.1f}, {y_dir.Y:.1f}, {y_dir.Z:.1f})")

            # DEBUG: Plane-Werte loggen
            logger.debug(f"[TNP v4.1] Circle plane: origin=({origin.X:.1f}, {origin.Y:.1f}, {origin.Z:.1f}), "
                        f"x_dir=({x_dir.X:.1f}, {x_dir.Y:.1f}, {x_dir.Z:.1f}), "
                        f"y_dir=({y_dir.X:.1f}, {y_dir.Y:.1f}, {y_dir.Z:.1f})")
            logger.debug(f"[TNP v4.1] Circle 2D center: ({cx:.2f}, {cy:.2f})")

            # Circle-Center in 3D: Origin + (cx, cy) Offset in der Plane
            center_3d = origin + x_dir * cx + y_dir * cy
            logger.debug(f"[TNP v4.1] Circle 3D center: ({center_3d.X:.2f}, {center_3d.Y:.2f}, {center_3d.Z:.2f})")

            # Native OCP Circle erstellen
            # Wire.make_circle() erstellt Circle MIT Center am Plane-Origin
            circle_plane = B3DPlane(origin=center_3d, x_dir=x_dir, z_dir=z_dir)
            circle_wire = Wire.make_circle(radius, circle_plane)
            face = make_face(circle_wire)

            faces.append(face)
            logger.debug(f"[TNP v4.1] Native Circle Face erstellt: r={radius:.2f} at ({cx:.2f}, {cy:.2f})")

        return faces

    def _create_faces_from_native_arcs(self, sketch, plane, profile_selector=None):
        """
        TNP v4.1: Erstellt native OCP Arc Faces aus Sketch-Arcs.

        Arcs benÃ¶tigen eine besondere Behandlung: Da ein Arc kein geschlossener
        Wire ist, erstellen wir eine planare Face aus Arc + Sehne (chord).
        Bei Extrusion entsteht so ein korrekter Zylinder-Abschnitt.

        Args:
            sketch: Sketch-Objekt mit arcs Liste
            plane: Build123d Plane fÃ¼r 3D-Konvertierung
            profile_selector: Optional selector for filtering arcs

        Returns:
            Liste von build123d Faces aus nativen OCP Arcs
        """
        from build123d import Wire, make_face, Face, Vector
        from OCP.GC import GC_MakeArcOfCircle
        from OCP.BRepBuilderAPI import BRepBuilderAPI_MakeEdge, BRepBuilderAPI_MakeWire, BRepBuilderAPI_MakeFace
        from OCP.gp import gp_Pnt
        from OCP.TopoDS import TopoDS_Edge, TopoDS_Wire, TopoDS_Face

        faces = []
        arcs_with_native_data = [
            a for a in sketch.arcs
            if hasattr(a, 'native_ocp_data') and a.native_ocp_data
        ]

        if not arcs_with_native_data:
            return []

        logger.info(f"[TNP v4.1] {len(arcs_with_native_data)} Arcs mit native_ocp_data gefunden")

        for arc in arcs_with_native_data:
            if arc.construction:
                continue  # Konstruktions-Arcs nicht extrudieren

            ocp_data = arc.native_ocp_data
            cx, cy = ocp_data['center']
            radius = ocp_data['radius']
            start_angle = ocp_data['start_angle']
            end_angle = ocp_data['end_angle']
            plane_data = ocp_data.get('plane', {})

            # Profiler-Selektor Matching
            if profile_selector:
                arc_centroid = (cx, cy)
                if not any(
                    abs(arc_centroid[0] - sel[0]) < 0.1 and
                    abs(arc_centroid[1] - sel[1]) < 0.1
                    for sel in profile_selector
                ):
                    continue

            # WICHTIG: AKTUELLE Plane-Orientation vom Sketch verwenden!
            # Die native_ocp_data['plane'] kann veraltet sein (GUI rotiert die Plane nach dem HinzufÃ¼gen)
            origin = Vector(*sketch.plane_origin)
            z_dir = Vector(*sketch.plane_normal)
            x_dir = Vector(*sketch.plane_x_dir)
            y_dir = Vector(*sketch.plane_y_dir)

            # FIX: Wenn y_dir Nullvektor ist (Bug), aus z_dir und x_dir berechnen
            if y_dir.X == 0 and y_dir.Y == 0 and y_dir.Z == 0:
                y_dir = z_dir.cross(x_dir)
                logger.debug(f"[TNP v4.1] Arc y_dir aus z_dir Ã— x_dir berechnet: ({y_dir.X:.1f}, {y_dir.Y:.1f}, {y_dir.Z:.1f})")

            # Arc-Center in 3D
            center_3d = origin + x_dir * cx + y_dir * cy

            # Arc-Parameter in 3D konvertieren
            start_rad = math.radians(start_angle)
            end_rad = math.radians(end_angle)

            # Start- und Endpunkte des Arcs in 3D
            start_3d = center_3d + x_dir * (radius * math.cos(start_rad)) + y_dir * (radius * math.sin(start_rad))
            end_3d = center_3d + x_dir * (radius * math.cos(end_rad)) + y_dir * (radius * math.sin(end_rad))

            # Mittelpunkt fÃ¼r den Arc
            mid_rad = (start_rad + end_rad) / 2
            mid_3d = center_3d + x_dir * (radius * math.cos(mid_rad)) + y_dir * (radius * math.sin(mid_rad))

            # Native OCP Arc Edge erstellen mit GC_MakeArcOfCircle (3 Punkte)
            gp_start = gp_Pnt(start_3d.X, start_3d.Y, start_3d.Z)
            gp_mid = gp_Pnt(mid_3d.X, mid_3d.Y, mid_3d.Z)
            gp_end = gp_Pnt(end_3d.X, end_3d.Y, end_3d.Z)

            arc_maker = GC_MakeArcOfCircle(gp_start, gp_mid, gp_end)
            if arc_maker.IsDone():
                # GC_MakeArcOfCircle.Value() gibt Geom_TrimmedCurve zurÃ¼ck
                # Wir mÃ¼ssen es in TopoDS_Edge wrappen
                arc_geom = arc_maker.Value()
                arc_edge_maker = BRepBuilderAPI_MakeEdge(arc_geom)
                if not arc_edge_maker.IsDone():
                    logger.warning("[TNP v4.1] Arc Edge Maker fehlgeschlagen")
                    continue
                arc_edge = arc_edge_maker.Edge()

                # Sehne (chord) mit OCP direkt erstellen
                chord_maker = BRepBuilderAPI_MakeEdge(gp_start, gp_end)
                if chord_maker.IsDone():
                    chord_edge = chord_maker.Edge()

                    # Wire aus Arc + Sehne mit OCP erstellen
                    wire_maker = BRepBuilderAPI_MakeWire()
                    wire_maker.Add(arc_edge)
                    wire_maker.Add(chord_edge)
                    wire_maker.Build()

                    if wire_maker.IsDone():
                        ocp_wire = wire_maker.Wire()

                        # Face aus Wire erstellen
                        face_maker = BRepBuilderAPI_MakeFace(ocp_wire)
                        if face_maker.IsDone():
                            ocp_face = face_maker.Face()

                            # Zu build123d Face konvertieren (direkt aus TopoDS_Face)
                            face = Face(ocp_face)
                            faces.append(face)
                            logger.debug(f"[TNP v4.1] Native Arc Face erstellt: r={radius:.2f}, {start_angle:.1f}Â°-{end_angle:.1f}Â°")
                        else:
                            logger.warning("[TNP v4.1] Face Maker fehlgeschlagen")
                    else:
                        logger.warning("[TNP v4.1] Wire Maker fehlgeschlagen")
                else:
                    logger.warning("[TNP v4.1] Chord Edge Maker fehlgeschlagen")
            else:
                logger.warning(f"[TNP v4.1] Arc Maker fehlgeschlagen fÃ¼r {arc}")

        return faces

    def _detect_matching_native_spline(self, coords, sketch, tolerance=0.5):
        """
        PrÃ¼ft ob ein Polygon-Kontur von einem nativen Spline stammt.

        Vergleicht Start/End-Punkte der Kontur mit Start/End der Native Splines.

        Args:
            coords: Liste von (x, y) Tupeln der Polygon-Kontur
            sketch: Sketch-Objekt mit native_splines Liste
            tolerance: Abstandstoleranz fÃ¼r Punktvergleich

        Returns:
            Spline2D Objekt wenn gefunden, sonst None
        """
        if not coords or len(coords) < 3:
            return None

        native_splines = getattr(sketch, 'native_splines', [])
        if not native_splines:
            return None

        import math

        # Start/End der Kontur
        c_start = coords[0]
        c_end = coords[-1]

        for spline in native_splines:
            if spline.construction:
                continue

            try:
                # Spline Start/End Punkte
                s_start = spline.start_point
                s_end = spline.end_point

                # Forward Match: Kontur-Start = Spline-Start, Kontur-End = Spline-End
                dist_start = math.hypot(c_start[0] - s_start.x, c_start[1] - s_start.y)
                dist_end = math.hypot(c_end[0] - s_end.x, c_end[1] - s_end.y)

                if dist_start < tolerance and dist_end < tolerance:
                    logger.info(f"  â†’ Spline Match (forward): {spline}")
                    return spline

                # Reverse Match: Kontur ist rÃ¼ckwÃ¤rts
                dist_start_rev = math.hypot(c_start[0] - s_end.x, c_start[1] - s_end.y)
                dist_end_rev = math.hypot(c_end[0] - s_start.x, c_end[1] - s_start.y)

                if dist_start_rev < tolerance and dist_end_rev < tolerance:
                    logger.info(f"  â†’ Spline Match (reverse): {spline}")
                    return spline

            except Exception as e:
                logger.debug(f"Spline Match Check fehlgeschlagen: {e}")
                continue

        return None

    def _create_wire_from_native_spline(self, spline, plane):
        """
        Erstellt einen Build123d Wire aus einem nativen Spline.

        Args:
            spline: Spline2D Objekt
            plane: Build123d Plane fÃ¼r 3D-Konvertierung

        Returns:
            Build123d Wire oder None bei Fehler
        """
        try:
            from build123d import Wire, Edge

            # Spline zu Edge konvertieren
            edge = spline.to_build123d_edge(plane)
            if edge is None:
                logger.warning("Native Spline â†’ Edge Konvertierung fehlgeschlagen")
                return None

            # Wire aus einzelner Edge erstellen
            wire = Wire([edge])
            logger.info(f"  â†’ Native Spline Wire erstellt ({len(spline.control_points)} ctrl pts)")
            return wire

        except Exception as e:
            logger.warning(f"Wire aus Native Spline fehlgeschlagen: {e}")
            return None

    def _create_wire_from_mixed_geometry(self, geometry_list, outer_coords, plane):
        """
        Erstellt einen Build123d Wire aus gemischter Geometrie (Line + Arc + Spline).

        NEUER ANSATZ: Nutze die Polygon-Koordinaten als Grundlage und ersetze
        Segmente durch native Kurven wo mÃ¶glich. So bleibt der Wire immer geschlossen.

        Args:
            geometry_list: Liste von (geom_type, geom_obj) Tupeln (dedupliziert!)
            outer_coords: Polygon-Koordinaten in Reihenfolge
            plane: Build123d Plane fÃ¼r 3D-Konvertierung

        Returns:
            Build123d Wire oder None bei Fehler
        """
        try:
            from build123d import Wire, Edge
            import math

            # Sammle alle einzigartigen Geometrie-Objekte
            unique_geoms = {}
            for geom_type, geom_obj in geometry_list:
                if geom_obj is not None and geom_type != 'gap':
                    obj_id = id(geom_obj)
                    if obj_id not in unique_geoms:
                        unique_geoms[obj_id] = (geom_type, geom_obj)

            logger.debug(f"  â†’ Mixed geometry: {len(unique_geoms)} unique objects, {len(outer_coords)} polygon points")

            # Strategie: Erstelle Edges fÃ¼r jede Geometrie und verbinde mit Linien
            edges = []
            used_geoms = set()

            # FÃ¼r jede einzigartige Geometrie, erstelle die entsprechende Edge
            for obj_id, (geom_type, geom_obj) in unique_geoms.items():
                if obj_id in used_geoms:
                    continue

                try:
                    if geom_type == 'spline':
                        # Native Spline Edge
                        edge = geom_obj.to_build123d_edge(plane)
                        if edge is not None:
                            edges.append(edge)
                            used_geoms.add(obj_id)
                            logger.debug(f"    Spline edge: OK ({len(geom_obj.control_points)} ctrl pts)")

                    elif geom_type == 'arc':
                        # Arc Edge
                        arc = geom_obj
                        start_rad = math.radians(arc.start_angle)
                        end_rad = math.radians(arc.end_angle)
                        mid_angle = (arc.start_angle + arc.end_angle) / 2
                        mid_rad = math.radians(mid_angle)

                        start_2d = (arc.center.x + arc.radius * math.cos(start_rad),
                                    arc.center.y + arc.radius * math.sin(start_rad))
                        mid_2d = (arc.center.x + arc.radius * math.cos(mid_rad),
                                  arc.center.y + arc.radius * math.sin(mid_rad))
                        end_2d = (arc.center.x + arc.radius * math.cos(end_rad),
                                  arc.center.y + arc.radius * math.sin(end_rad))

                        start_3d = plane.from_local_coords(start_2d)
                        mid_3d = plane.from_local_coords(mid_2d)
                        end_3d = plane.from_local_coords(end_2d)

                        from OCP.GC import GC_MakeArcOfCircle
                        from OCP.BRepBuilderAPI import BRepBuilderAPI_MakeEdge
                        from OCP.gp import gp_Pnt

                        arc_maker = GC_MakeArcOfCircle(
                            gp_Pnt(*start_3d.to_tuple()),
                            gp_Pnt(*mid_3d.to_tuple()),
                            gp_Pnt(*end_3d.to_tuple())
                        )
                        if arc_maker.IsDone():
                            edge_builder = BRepBuilderAPI_MakeEdge(arc_maker.Value())
                            if edge_builder.IsDone():
                                edge = Edge(edge_builder.Edge())
                                edges.append(edge)
                                used_geoms.add(obj_id)
                                logger.debug(f"    Arc edge: OK (r={arc.radius:.2f})")

                    elif geom_type == 'line':
                        # Line Edge
                        p1 = plane.from_local_coords((geom_obj.start.x, geom_obj.start.y))
                        p2 = plane.from_local_coords((geom_obj.end.x, geom_obj.end.y))
                        edge = Edge.make_line(p1, p2)
                        edges.append(edge)
                        used_geoms.add(obj_id)

                except Exception as e:
                    logger.debug(f"    {geom_type} edge failed: {e}")

            if not edges:
                logger.warning("  â†’ Keine Edges erstellt")
                return None

            # Versuche Wire aus Edges zu bauen
            try:
                wire = Wire(edges)
                if wire.is_closed:
                    logger.info(f"  â†’ Mixed Geometry Wire: {len(edges)} edges, geschlossen")
                    return wire
                else:
                    logger.debug(f"  â†’ Wire nicht geschlossen, versuche Polygon-Fallback")
            except Exception as e:
                logger.debug(f"  â†’ Wire aus Edges fehlgeschlagen: {e}")

            # Fallback: Wenn Wire nicht geschlossen ist, nutze Polygon mit nativen Kurven
            # wo mÃ¶glich, aber fÃ¼lle LÃ¼cken mit Linien
            logger.debug("  â†’ Fallback: Erstelle Wire aus Polygon-Koordinaten")
            poly_pts = [plane.from_local_coords((p[0], p[1])) for p in outer_coords]
            try:
                wire = Wire.make_polygon(poly_pts)
                logger.info(f"  â†’ Polygon Wire Fallback: {len(poly_pts)} Punkte")
                return wire
            except Exception as e:
                logger.warning(f"  â†’ Polygon Wire auch fehlgeschlagen: {e}")
                return None

        except Exception as e:
            logger.warning(f"Wire aus Mixed Geometry fehlgeschlagen: {e}")
            import traceback
            traceback.print_exc()
            return None

    # NOTE: These methods delegate to shape_builders module for maintainability
    
    def _lookup_geometry_for_polygon(self, poly, sketch):
        """Delegates to shape_builders module - see lookup_geometry_for_polygon."""
        return lookup_geometry_for_polygon(poly, sketch)

    def _get_plane_from_sketch(self, sketch):
        """Delegates to shape_builders module - see get_plane_from_sketch."""
        return get_plane_from_sketch(sketch)

    def _update_mesh_from_solid(self, solid):
        """
        Phase 2: Invalidiert Mesh-Cache - Mesh wird lazy regeneriert bei Zugriff.
        (Single Source of Truth Pattern)
        """
        if not solid:
            return

        # Invalidiere Cache - nÃ¤chster Zugriff auf vtk_mesh/vtk_edges regeneriert
        self.invalidate_mesh()

        # Legacy Support leeren
        self._mesh_vertices = []
        self._mesh_triangles = []

    def export_stl(self, filename: str) -> bool:
        """STL Export via Kernel (Build123d). Kein Mesh-Fallback."""
        if not HAS_BUILD123D or self._build123d_solid is None:
            logger.error("STL-Export fehlgeschlagen: Kein Build123d-Solid vorhanden")
            return False

        # OCP Feature Audit: Offene-Kanten-Check vor Export
        self._check_free_bounds_before_export()

        try:
            export_stl(self._build123d_solid, filename)
            return True
        except Exception as e:
            logger.error(f"STL-Export fehlgeschlagen: {e}")
            return False

    def _check_free_bounds_before_export(self):
        """
        OCP Feature Audit: PrÃ¼ft ob Body offene Kanten hat vor Export.

        Offene Shells erzeugen STL-Dateien mit LÃ¶chern, die fÃ¼r 3D-Druck
        unbrauchbar sind. Diese Warnung hilft dem User das Problem zu erkennen.
        """
        from config.feature_flags import is_enabled
        if not is_enabled("export_free_bounds_check"):
            return

        try:
            from OCP.ShapeAnalysis import ShapeAnalysis_FreeBounds
            from OCP.TopExp import TopExp_Explorer
            from OCP.TopAbs import TopAbs_WIRE

            fb = ShapeAnalysis_FreeBounds(self._build123d_solid.wrapped)
            closed_compound = fb.GetClosedWires()
            open_compound = fb.GetOpenWires()

            # GetClosedWires/GetOpenWires geben TopoDS_Compound zurÃ¼ck
            def count_wires(compound):
                exp = TopExp_Explorer(compound, TopAbs_WIRE)
                n = 0
                while exp.More():
                    n += 1
                    exp.Next()
                return n

            n_closed = count_wires(closed_compound)
            n_open = count_wires(open_compound)

            if n_open > 0:
                logger.warning(
                    f"âš ï¸ Body '{self.name}' hat {n_open} offene Kante(n)! "
                    f"STL kÃ¶nnte LÃ¶cher haben â†’ 3D-Druck problematisch."
                )
            elif n_closed > 0:
                logger.warning(
                    f"âš ï¸ Body '{self.name}' hat {n_closed} geschlossene freie Wire(s). "
                    f"MÃ¶gliches internes Shell-Problem."
                )
            else:
                logger.debug(f"Export Free-Bounds Check: Body '{self.name}' ist geschlossen (OK)")

        except Exception as e:
            logger.debug(f"Free-Bounds Check fehlgeschlagen: {e}")

    def _export_stl_simple(self, filename: str) -> bool:
        """Primitiver STL Export aus Mesh-Daten (Letzter Ausweg)"""
        try:
            with open(filename, 'w') as f:
                f.write(f"solid {self.name}\n")
                for tri in self._mesh_triangles:
                    v0 = self._mesh_vertices[tri[0]]
                    v1 = self._mesh_vertices[tri[1]]
                    v2 = self._mesh_vertices[tri[2]]
                    f.write(f"  facet normal 0 0 1\n")
                    f.write(f"    outer loop\n")
                    f.write(f"      vertex {v0[0]} {v0[1]} {v0[2]}\n")
                    f.write(f"      vertex {v1[0]} {v1[1]} {v1[2]}\n")
                    f.write(f"      vertex {v2[0]} {v2[1]} {v2[2]}\n")
                    f.write(f"    endloop\n")
                    f.write(f"  endfacet\n")
                f.write(f"endsolid {self.name}\n")
            return True
        except Exception as e:
            logger.error(f"Legacy STL-Export fehlgeschlagen: {e}")
            return False

    # === PHASE 8.2: Persistente Speicherung fÃ¼r TNP ===
    # (Serialization methods delegated to body_serialization module)

    def to_dict(self) -> dict:
        """
        Serialisiert Body zu Dictionary fÃ¼r persistente Speicherung.
        
        Delegates to body_serialization.body_to_dict module.
        """
        return body_to_dict(self)

    @classmethod
    def from_dict(cls, data: dict) -> 'Body':
        """
        Deserialisiert Body aus Dictionary.
        
        Delegates to body_serialization.body_from_dict module.
        """
        return body_from_dict(cls, data, cls)

    @classmethod
    def _normalize_status_details_for_load(cls, status_details: Any) -> dict:
        """Delegate to body_serialization module."""
        return _normalize_status_details_for_load(status_details)


__all__ = ['Body', 'HAS_OCP', 'HAS_BUILD123D']
